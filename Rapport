\documentclass[a4paper,10pt]{article}
%\documentclass[a4paper,10pt]{scrartcl}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{indentfirst}

\title{Rapport Systèmes et Réseaux II}
\author{Perion Maxence, Pinon Alexandre}
\date{}

\renewcommand*\contentsname{Sommaire}
 \renewcommand{\listfigurename}{Liste des images}%

\pdfinfo{%
  /Title    ()
  /Author   ()
  /Creator  ()
  /Producer ()
  /Subject  ()
  /Keywords ()
}

\begin{document}

\maketitle 
\tableofcontents

\newpage
\section{Introduction}
L'objectif de ces Travaux Pratiques a été de réaliser un serveur complet pour une agence fictive. Pour cela, nous étions en possession de deux machines: un serveur/routeur ainsi qu'un client, une machine simulant la connexion d'un appareil au réseau de l'agence. Nous sommes partis de zéro et dans un premier temps nous avons installé Debian sur notre serveur, une distribution GNU/Linux, sans interface graphique via le réseau IEM pour avoir un outil de travail. Nous avons premièrement défini et paramétré notre adressage et routage, c'est à dire la façon d'attribuer les adresses IP et comment communiquer sur les différents réseaux. Afin de s'affranchir des adresses IP et pour s'approcher d'un cadre plus réaliste, nous avons deuxièmement mis en place sur le serveur un service de DNS, permettant d'utiliser des noms de domaines agissant comme des alias pour des adresses IP.  Troisièmement, nous avons mis en place ce qui pourrait servir pour héberger un site web pour notre agence grâce à une suite d'outils appelée un LAMP. Pour finir, nous avons mis en place un service d'authentification centralisé LDAP ainsi qu'un service de partage de fichiers Samba.

\section{Installation d'une distribution GNU/Linux sans interface graphique}

\subsection{Installation via le réseau}

Pour commencer à travailler, la première étape a été d'installer un système d'exploitation: une distribution GNU/Linux sans interface graphique, à savoir Debian dans sa version ``Bullseye'' (Debian 11). Sans celui-ci, il nous serait impossible de réaliser la moindre tâche avec notre serveur. Le fait qu'il s'agisse d'une distribution Linux va nous permettre de pouvoir manipuler les différents services autant que nous le souhaitons, avec un système de paquets très pratiques. Afin d'installer cette distribution, les administrateurs Systèmes et Réseaux nous ont mit à disposition un boot via le réseau. En temps normal pour installer un système d'exploitation, quel qu'il soit, les utilisateurs utilisent des clés USB ou un disque dur qui permette de démarrer sur celui-ci et d'installer le système d'exploitation à partir de la. Le principe est le même dans notre cas sauf que cette installation se fait par le réseau IEM qui est le réseau de l'université de Bourgogne. Pour lancer l'installation nous devions brancher notre serveur sur le réseau et le démarrer depuis le bios en sélectionnant le bouton "PXE IEM". Une fois l'installation démarrée nous devions suivre les étapes d'installation, telles que définir le nom et mot de passe du root, choisir/créer des partition du disque dur, donner un nom à la machine, ... 

\subsection{Partitions du disque}

Lors de l'installation du système d'exploitation il est nécessaire de réaliser des partitions du disque dur pour scinder son espace de mémoire afin d'être utilisé pour différentes choses en simultané et sans risque de collisions ou de chevauchements. Notre disque après l'installation est désormais composé de 3 partitions et il est possible de les afficher ainsi que des détails supplémentaires avec la commande:
\begin{lstlisting}[language=bash]
  $ sudo fdisk -l
\end{lstlisting}

 % partitionDisque.PNG: 1115x234 px, 96dpi, 29.51x6.19 cm, bb=0 0 836 176
\begin{figure}[!h]
\centerline{\includegraphics[width=15cm]{images/partitionDisque.PNG}}
\caption{Les 3 partitions d'un disque}
\label{fig1}
\end{figure}

Sur la figure \ref{fig1}, nous pouvons voir distinctement les différentes partitions, dont la partition générale sda1 de 237.5 Go qui nous permet de stocker différents fichiers tels que des paquets pour l'utilisation de Debian ou encore différents fichiers de configuration par exemple. De plus, nous pouvons voir la partition qui permet le mécanisme de swap. Il s'agit d'un mécanisme du système d'exploitation qui va se servir du disque dur pour stocker des informations normalement stockées dans la RAM, lorsque celle-ci est saturée. Il y a également un partition étendue qui est un conteneur de partitions logiques: sda2.

\subsection{TODO Synthèse des commandes du gestionnaire de paquets TODO}
TODO
Sous Debian il existe de multiple gestionnaire de paquets, mais le plus couramment utilisé est le gestionnaire "apt".
\subsection{Mise à jour du système}
\subsection{Les paquets}
p
\newline
\newline
\par
Maintenant que Debian est installé sur notre routeur, il est prêt à être configuré et utilisé pour différentes tâches. 
\newline

\section{Paramétrage du réseau}
Pour pouvoir commencer à communiquer entre différentes machines, nous avons ensuite défini la répartition des adresses IP pour chaque groupe (chaque agence) et paramétré en conséquences les différentes interfaces réseaux sur le routeur puis le client. Pour cela, nous nous sommes connectés au réseau IEM via la carte réseau intégré à la carte mère sur routeur, la première carte réseau externe a été branchée au switch afin de permettre la communication avec les autres groupes, donc le réseau d'interconnexion et dernièrement la deuxième carte réseau externe est utilisée pour le réseau privé mais puisque nous n'avons qu'un client, nous l'avons directement connecté. Toutes les connexions ont étés effectuées via des câbles Ethernet standard. Ici le but de la manipulation est de mettre en place un réseau d'entreprises et d'une infrastructure de services.

\subsection{Répartition des adresse IP (réseau d'Interconnexion entre agences et réseau privé de l'agence)}
Chaque binôme du groupe de TP s'est vu attribué une adresse IP de classe C et un masque qui sera utilisé pour le réseau d’interconnexion. Puisqu'il y a 5 binômes dans notre groupe de TP, nous avons pris une adresse dans la plage allant de 192.168.1.1 à 192.168.1.5. Pour la même raison, nous avons défini le masque du réseau d'Interconnexion à 255.255.255.248, résultat que nous avons obtenu en ajoutant 3 bits à 1 le plus à gauche possible au masque standard de classe C (255.255.255.0). Ces 3 bits supplémentaires nous permettent de coder 2\textsuperscript{3}=8  sous réseaux, ce qui suffit pour nos 5 groupes.
\newline
 % ReseauInterco&Prive.png: 720x310 px, 96dpi, 19.05x8.20 cm, bb=0 0 540 232
\begin{figure}[!h]
\centerline{\includegraphics[width=15cm]{images/ReseauInterco&Prive.png}}
\caption{Tableau des adresses IP de chaque groupe}
\label{fig2}
\end{figure}

\par
Le tableau de la figure \ref{fig2} récapitule les adresses IP allouées pour chaque réseau et pour chaque groupe. Pour notre cas nous sommes dans le groupe 2 ce qui signifie que notre adresse sur le réseau d’interconnexion est 192.168.1.2 et notre adresse de réseau privé est 10.1.2.0.
\newline
\par
Après avoir défini ces adresses et ces réseaux sur le papier, il est désormais temps de configurer les machines afin de les implémenter concrètement.

\subsection{Les interfaces réseaux du routeur}
Les adresses que nous venons de répartir entre chaque groupe et réseaux doivent être utilisées par le routeur. Nous allons donc maintenant expliquer comment nous avons paramétré les interfaces réseaux sur le routeur. Pour cela, nous avons travailler avec le fichier /etc/network/interfaces qui régis le fonctionnement des interfaces réseaux de la machine au niveau du noyau du système d'exploitation. Une interface réseau correspond à une carte réseau (en général) et il est possible à partir de son de la configurer (adresse statique, adresse du réseau, masque, gateway, ...). La gateway d'une telle configuration est la machine qui doit être utilisé pour passer d'un réseau à un autre. En d'autres termes, il s'agit de la ``porte d'accès'' à utiliser. Par exemple si une machine du réseau privé veut communiquer avec une autre machine située sur le réseau IEM, elle devra utiliser le serveur pour router ses paquets. Nous avons modifié le fichier pour obtenir le résultat de la figure \ref{fig3}. 

\begin{figure}[!h]
\centerline{ \includegraphics[width=15cm]{images/interfacesRouteur.png}}
\caption{Fichier de configuration des interfaces réseaux du routeur}
\label{fig3}
\end{figure}

Il est possible d'afficher les interfaces réseaux disponibles sur la machine dans le shell avec la commande:
\begin{lstlisting}[language=bash] 
    $ ip a 
\end{lstlisting} 
Cette commande a pour intérêt de nous faire connaître rapidement les adresses MAC et/ou IP de chaque interface. Elle nous a permit de connaître le nom des interfaces à utiliser dans notre fichier de configuration mais elle permet également de savoir si une interface est active ``UP'' ou pas ``DOWN''. En effet, durant les phases de tests il était important de savoir quelles interfaces étaient allumées ou éteintes. Il est possible qu'après une mauvaise configuration ou un problème, une interface soit éteinte. Il existe des commandes utilitaires pour les manipuler, l'une allumant l'interface nommée ``interface'' et l'autre l'éteignant. 

\begin{lstlisting}[language=bash] 
    $ ifup interface
    $ ifdown interface
\end{lstlisting}

Pour le fichier de configuration (figure \ref{fig3} ci-dessus) , nous pouvons voir que nous avons configur'' les 3 interfaces (donc les 3 ports Ethernet que possède notre routeur), ainsi que l'interface ``lo" qui représente le loopback. Le loopback est la ``boucle'' locale: c'est une interface virtuelle qui permet de définir à une machine ``elle même'', notamment lors de l'utilisation de l'adresse ``localhost''.  Pour chacune des interfaces, nous avons donc défini leur adresse (address), leur masque (netmask) et leur réseau (network). Pour l'interface ``eno1" qui est relié au réseau IEM, nous avons plusieurs informations supplémentaire: l'adresse de broadcast (adresse utilisée pour transmettre un message à toutes les autres machines d'un réseau), la passerelle (gateway), les dns, ... Nous pouvons voir que l'interface ``eno1" est relier au réseau IEM car pour le réseau nous avons indiqué l'adresse 172.31.20.1 qui est l'adresse du routeur du réseau IEM fournie par les intervenants des travaux pratiques. Le raisonnement est le même pour les interfaces ``enp3s0" et ``enp1s0", pour lesquels nous avons indiqué respectivement pour le réseau les adresses 10.1.2.0 et 192.158.1.0. Il s'agit donc des réseaux d'interconnexion et privé. Les entrées "dns-nameservers" et "pre-up" seront expliquées plus en détail ultérieurement. Une fois le fichier de configuration des interfaces réseaux édité à notre souhait, ses informations ne sont pas prises en compte immédiatement: il est nécessaire de redémarrer le service réseau associé, en tant que root ou alors avec sudo:

\begin{lstlisting}[language=bash] 
    $ service networking restart
    ou
    $ /etc/init.d/networking restart
    ou
    $ systemctl restart networking
\end{lstlisting}
Ces 3 commandes permettent de façon similaire de redémarrer le service réseau. 
\newline
\par Cependant, ces configurations sur le routeur ne sont pas les seules nécessaires pour que tous les réseaux fonctionnent: il est également nécessaire de configurer la machine client qui est connectée au réseau privé, notamment pour qu'elle connaisse comment communiquer avec une machine du réseau d'interconnexion ou du réseau IEM.

\subsection{Les interfaces réseaux du client}

Nous allons maintenant expliquer comment nous avons paramétré les interfaces réseaux sur le client. De la même manière que pour le routeur, le fichier de configuration se trouve dans /etc/network/interfaces et sa forme est identique a celui du routeur. Cependant, cette fois il n'est nécessaire de configurer qu'une seule interface, la seule qui est utilisée et qui est connectée au routeur par le réseau privé. Les informations que nous retrouvons dans ce fichier sont les suivantes. On peut y retrouver l'adresse de la machine, le masque et le réseau, ainsi que la gateway.

\begin{lstlisting}[language=bash]
    auto enp11s0
    iface enp11s0 inet static
                address 10.1.2.2
                netmask 255.255.255.0
                network 10.1.2.0
                gateway 10.1.2.1
\end{lstlisting}

On voit ici que l'IP renseigné pour le réseau de l'interface ``enp11s0" est 10.1.2.1, qui est l'adresse de notre sous réseau. L'adresse IP de notre client est désormais fixée à 10.1.2.2.
Comme pour le routeur, afin d'appliquer les changements il faut redémarrer le service avec l'une des trois commandes évoquées précédemment. Par la suite, toutes ces configurations vont permettre au client et au routeur de communiquer avec le reste des machines des autres groupes. 

\subsection{Communication basique sans table de routage}

Nous allons maintenant aborder la communication entre différentes machines, car nous avons pour but de simuler un réseau en entreprise, et par conséquent il faut que nos machines puissent communiquer. Il est également nécessaire que le routeur soit en capacité de rediriger correctement les paquets des machines la où ils doivent être conduits. Par défaut, le client et le routeur peuvent communiquer car ils sont branchés physiquement entre eux. Il en est de même pour tous les routeurs qui sont branchés sur le réseau IEM car ils sont tous sur le même réseau. Afin de tester les communication entre différentes machines, que ce soit routeurs ou clients, nous pouvons essayer de ping la machine, à condition que le protocol soit activé sur la cible, avec cette commande:
\begin{lstlisting}[language=bash]
  $ ping ip_machine
\end{lstlisting}

Pour montrer le bon fonctionnement jusqu'ici, nous allons avec notre routeur, essayer de ping le routeur d'un autre groupe via le réseau IEM:

\begin{figure}[!h]
\centerline{ \includegraphics[width=15cm]{images/routeurPingRouteur.png}}
\caption{Ping de notre routeur à un autre}
\label{fig4}
\end{figure}

Nous pouvons voir sur la figure \ref{fig4} que les paquets sont bien envoyés et reçus par notre correspondant et tout s'est bien déroulé. Cependant si notre routeur ou notre client veut ping ou plus globalement communiquer avec un client d'un autre groupe qui est donc sur un autre réseau privé, nous allons devoir lui indiquer le chemin pour aller jusqu'à celui-ci, ce qui est réaliser avec un table de routage.

\subsection{Mise en place de la table de routage}

L'étape suivante est la création de routes afin de permettre la communication entre les différentes machines de la simulation: le client et le routeur, mais également entre chaque routeurs (les autres agences) et entre différents clients de différentes agences.
\par
Dans la configuration actuelle, il nous est impossible de ping le client qui est connecté ``derrière'' un autre routeur que le notre, car notre routeur ne connaîtra pas de chemin (route) par lequel acheminer les paquets vers cette cible. Pour arriver à faire ceci, il nous faut mettre en place une table de routage.
Il s'agit d'une table qui permet d'indiquer les routes possibles pour atteindre certains réseaux et avec une adresse de redirection dite de ``default'' qui indique vers qui envoyer le paquet si on ne connaît pas de chemin. Si aucun chemin n'est trouvé, l'erreur ``Network Unreachable'' sera renvoyé à l'émetteur du paquet. 

Il est possible d'afficher les routes de notre routeur dans le shell avec la commande:
\begin{lstlisting}[language=bash] 
    $ ip route
\end{lstlisting} 

\begin{figure}[!h]
\centerline{ \includegraphics[width=15cm]{images/routeRouteur.png}}
\caption{Route de notre routeur}
\label{fig5}
\end{figure}

Nous pouvons voir sur la figure \ref{fig5} que la route par défaut à emprunter pour tous les paquets qui arrivent, si aucune des routes décrites ne convient, est la route par l'adresse 172.31.20.1. Il s'agit de l'adresse du routeur du réseau IEM, qui va à son tour regarder dans ses tables (ou non si le destinataire est directement accessible) une route correspondante ou utiliser sa route par défaut et ainsi de suite. Nous pouvons également voir que les paquets à destination du réseau 10.1.2.0/24 sont dirigé vers l'adresse 10.1.2.1. Il s'agit de l'adresse de notre serveur mais sur le réseau privé: le paquet est donc routé par une autre interface afin d'atteindre le sous réseau privé de destination. Le principe est le même pour le réseau d'interconnexion, et le réseau IEM qui sont également redirigés vers d'autres interfaces sur le serveur mais qui sont toutes différentes. Pour finir, nous pouvons voir que le traffic n'ayant pas trouvé de route sera envoyé vers l'adresse du routeur du réseau IEM (route par défaut).
\newline
\par
Les routes statiques sont ajoutées dans le noyau de notre serveur par l'intermédiaire de la commande ip route, utilisée en tant que root ou avec sudo dans le cas contraire: 
\begin{lstlisting}[language=bash] 
    $ ip route add {network} via {IP}
\end{lstlisting}

Ces routes fonctionnent pour notre réseau privé, le réseau d'interconnexion ou le réseau IEM. Cependant, elles ne nous permettent toujours pas de communiquer avec un router connecté derrière le serveur d'un autre groupe. Pour cela,  il va nous falloir ajouter encore une route et de la même façon il nous faudra une route pour chaque groupe avec lequel nous souhaitons communiquer. Le groupe avec qui nous effectuons les tests ont pour adresse (leur serveur) sur le réseau d'interconnexion l'adresse IP 192.168.1.1 et pour adresse de leur réseau privé 10.1.1.0. L'adresse IP de leur client dans leur réseau privé est 10.1.1.1.
\newline
Pour pouvoir communiquer avec une machine sur leur réseau privé, nous devons donc appliquer sur notre routeur la commande : 
\begin{lstlisting}[language=bash] 
    $ ip route add 10.1.1.0/24 via 192.168.1.1
\end{lstlisting}
Cette commande permet de dire que tout ce qui est à destination de leur réseau privé, d'adresse IP 10.1.1.0, doit être redirigé vers la machine ayant l'adresse 192.168.1.1, c'est à dire leur routeur. Leur routeur sera alors atteint en empruntant le réseau d'interconnexion. Nous pouvons désormais, avec notre routeur, taper la commande qui permet de ping leur client:
\begin{lstlisting}[language=bash] 
    $ ping 10.1.1.1
\end{lstlisting}
Le ping du client de leur réseau privé fonctionne désormais: nos paquets sont bien envoyés et réceptionnés. 

\subsection{Règles iptables pour laisser l'accès a internet a une machine}

L'architecture de notre réseau commence à prendre forme, mais un client sur notre réseau privé ne peut toujours pas accéder à internet: pour le moment seul le routeur est connecté à internet à travers le réseau IEM. Pour réaliser cette manoeuvre appelée une translation d'adresse, nous allons utiliser les règles ``iptables":

\begin{lstlisting}[language=bash] 
    $ iptables -t nat -A POSTROUTING -s 10.1.2.0/24 
    -o eno1 -j MASQUERADE
\end{lstlisting}

Cette commande permet d'indiquer au routeur qu'il doit retransmettre les paquets reçus du réseau privé (source 10.1.2.0/24) sur le réseau IEM (interface de sortie``eno1"). L'option masquerade permet d'indiquer que le paquet sera retransmis par translation d'adresse, c'est à dire que le routeur va stocker dans son noyau les informations sur l'émetteur de ce paquet (adresse, port, ...) puis va l'émettre à nouveau en son nom. Lorsque le routeur recevra une réponse, il pourra consulter la table de translation dans son noyau pour trouver à qui il doit transférer le paquet.
\newline
\par
Afin de vérifier si notre routeur était capable d'utiliser internet, nous avons installé ``links2" qui a été auparavant installé via le gestionnaire de paquet "apt". Il s'agit d'une commande qui permet de consulter des pages web avec un affichage non graphique, que nous utilisons avec la commande: 
\begin{lstlisting}[language=bash] 
    $ links2 google.com
\end{lstlisting}
Et en effet, notre routeur était capable de surfer sur le web. Nous avons également appliqué cette procédure pour notre client afin de vérifier si il était connecté à internet.
\newline\newline
\par
L'inconvénient de cette nouvelle règle iptable est que n'importe quel client qui arrive à se connecter au réseau privé peut avoir accès à toutes les ressources et se connecter au réseau IEM ou d'interconnexion. Nous pouvons restreindre l'accès à notre réseau privé en n'attribuant une adresse IP qu'à certaines adresses MAC connues, via le service DHCP.

\section{Service DHCP}
Maintenant partons du principe que nous souhaitons connecter plusieurs clients sur notre réseau privé, il est alors important d'approfondir le paramétrage de notre réseau avec la mise en place d'un service DHCP afin de définir les adresses IP à attribuer pour les machines (clients) se connectant sur notre réseau privé.
\subsection{Mise en place du DHCP}

Avant toute chose, nous avons cherché et installé le bon paquet pour l'utilisation du DHCP:
\begin{lstlisting}[language=bash] 
    $ apt-get install isc-dhcp-server
\end{lstlisting}
Une fois l'installation effectuée, nous nous sommes rendu dans le fichier /etc/default/isc-dhcp-server qui a été installé avec le paquet via la commande décrite précedemment. Dans ce fichier de configuration, il faut renseigner avec quelle interface réseau nous voulons travailler pour la suite de la mise du DHCP.

\begin{figure}[!h]
\centerline{\includegraphics[width=15cm]{images/dhcpServeur.png}}
\caption{Interface du DHCP}
\label{fig6}
\end{figure}

Puisque nous voulons allouer automatiquement l'adresse IP de chaque client connecté à notre réseau privé nous avons utilisé l'interface ``enp3s0", qui est celle utilisée pour notre réseau privé. Nous travaillons uniquement en IPv4 donc nous avons laissé vide les interfaces pour IPv6.
\newline
\par
Ceci étant fait, nous pouvons désormais passer au paramétrage en détails du serveur DHCP, comme par example la plage d'adresse IP qui va être subnetée, ou encore fixer des adresses IP pour des postes ayant des adresses MAC définies. Cette configuration du serveur DHCP se fait sur le fichier ``/etc/dhcp/dhcpd.conf".

\begin{figure}[!h]
\centerline{ \includegraphics[width=15cm]{images/dhcpdConfServeur.png}}
\caption{Configuration du serveur DHCP}
\label{fig7}
\end{figure}

Sur la figure \ref{fig7} nous pouvons voir que le réseau subneté est notre réseau privé ayant comme adresse 10.1.2.0 et le masque 255.255.255.0. Nous attribuons une adresse fixe à plusieurs clients car durant nos tests il est arrivé que nous ayons des clients différents et sans cela, il aurait été impossible pour le cient de se connecter au réseau privé. Afin d'attribuer une adresse fixe, il suffit d'indiquer l'adresse qu'on lui fixe avec comme entrée ``fixed-address" ainsi que son adresse MAC ``hardware ethernet".
Nous avons également renseigné différentes informations concernant le DNS mais nous aborderons le sujet plus tard.

De la même façon que pour les interfaces réseaux, quand une modification est apportée il faut redémarrer le service correspondant afin de prendre en compte les changements effectués, avec la commande:

\begin{lstlisting}[language=bash] 
    $ service isc-dhcp-server restart
\end{lstlisting}

Il est également possible de démarrer le service, si il est arrêté, avec:
\begin{lstlisting}[language=bash] 
    $ service isc-dhcp-server start
\end{lstlisting}
Ou a contrario nous pouvons le stopper si besoin avec:
\begin{lstlisting}[language=bash] 
    $ service isc-dhcp-server stop
\end{lstlisting}
Il est également possible d'afficher les erreurs en cas de soucis avec:
\begin{lstlisting}[language=bash] 
    $ cat /var/log/syslog
\end{lstlisting}
Et finalement on peut afficher l'interface d'écoute du démon par l'intermédiaire de la commande:
\begin{lstlisting}[language=bash] 
    $ ps ax | grep dhcpd
\end{lstlisting}
En cas de problème ou pour simplement monitorer ce qu'il se passe sur notre serveur, il peut être interessant de garder une trace de ce qu'il se passe avec le service. Pour cela, nous avons besoin de mettre un place un système de logs dans notre DHCP.

\subsection{Système de log pour le DHCP}

\section{Sauvegarde automatique}
\subsection{Rsync}
\subsection{Cron}

Conclusion tp 1

Introduction tp 1bis

\section{Interrogation d'un serveur DNS}
\subsection{Les commandes host, dig et nslookup}
\subsection{Fichier de renseignement du serveur DNS}
\subsection{Rôle du fichier /etc/hosts}

\section{Installation d'un DNS}

Pour la suite des explications, il est important de préciser que nous avons choisi comme nom de domaine: agence.altantide.

\subsection{Mise en place du DNS}

Création des deux zones, (named.conf.local et named.conf.default-zone), copie du fichier "db.local" en "deb.agence.atlantide", copie de "db.127" en "db.agence.atlantide.inv" pour la zone de recherche inversé. Ajout des forwarders dans "named.conf.options". Redémarrage avec systemctl restart bind 9. Changement du dhcp pour prendre en compte le serveur DNS.
"option domain-name "agence.atlantide" fournit le nom de domaine, dans ce cas il sert a faire référence aux ordinateurs du réseau par leurs nom sans ajouter le nom de domaine.

\subsection{Test réaliser afin de valider le DNS}
named-checkzone et named-checkconf pour vérifier la syntaxe
/var/log/syslog pour voir les erreurs si présente au démarrage
depuis le serveur : nslookup ip-client
depuis le serveur : nslookup nom-client
depuis un client connecté en filaire au routeur : nslookup ip-client
depuis un client connecté en filaire au routeur : nslookup nom-client
vers le serveur d'une autre agence : 
vers le client d'une autre agence :

Conclusion tp 1bis

Introduction tp 2

\section{Installation d'un serveur LAMP}
\subsection{Installation et mise en place d'Apache}

Test, localisation de la page web, création du compte utilisateur développeur, modification du serveur pour que www soit associé au dev web (crée dabs /srv), les bon droits, mise en place du virtuals hosts pointant sur /srv/www 

\subsection{Installation et mise en place de PostgreSQL}

Déroulement...

\subsection{Installation et mise en place de PHP}

Programme PHP qui se connecte a PostgreSQL et affichage infos pour la vérification.

\subsection{Installation et mise en place de MySQL}

Comme pour PostgreSQL et php

\subsection{Installation et mise en place d'un PDO}

\section{Script de routage et matrice de filtrage}
\subsection{Scripts de routage au démarrage}
\subsection{Règles iptables de la matrice de filtrage}


Conclusion tp 2

Introduction 3

\section{}
\subsection{}
\subsection{}

Conclusion tp 3

\section{Conclusion}
\section{Annexe}
\listoffigures  
\end{document}
