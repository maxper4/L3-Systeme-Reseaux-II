\documentclass[a4paper,10pt]{article}
%\documentclass[a4paper,10pt]{scrartcl}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{float}

\title{Rapport Systèmes et Réseaux II}
\author{Perion Maxence, Pinon Alexandre}
\date{}

\renewcommand*\contentsname{Sommaire}
 \renewcommand{\listfigurename}{Liste des images}%

\pdfinfo{%
  /Title    ()
  /Author   ()
  /Creator  ()
  /Producer ()
  /Subject  ()
  /Keywords ()
}

\begin{document}

\maketitle 
\tableofcontents

\newpage
\section{Introduction}
L'objectif de ces Travaux Pratiques a été de réaliser un serveur complet pour une agence fictive. Pour cela, nous étions en possession de deux machines: un serveur/routeur ainsi qu'un client, une machine simulant la connexion d'un appareil au réseau de l'agence. Nous sommes partis de zéro et dans un premier temps nous avons installé Debian sur notre serveur, une distribution GNU/Linux, sans interface graphique via le réseau IEM pour avoir un outil de travail. Nous avons premièrement défini et paramétré notre adressage et routage, c'est à dire la façon d'attribuer les adresses IP et comment communiquer sur les différents réseaux. Afin de s'affranchir des adresses IP et pour s'approcher d'un cadre plus réaliste, nous avons deuxièmement mis en place sur le serveur un service de DNS, permettant d'utiliser des noms de domaines agissant comme des alias pour des adresses IP.  Troisièmement, nous avons mis en place ce qui pourrait servir pour héberger un site web pour notre agence grâce à une suite d'outils appelée un LAMP. Pour finir, nous avons mis en place un service d'authentification centralisé LDAP ainsi qu'un service de partage de fichiers Samba.

\section{Installation d'une distribution GNU/Linux sans interface graphique}

\subsection{Installation via le réseau}

Pour commencer à travailler, la première étape a été d'installer un système d'exploitation: une distribution GNU/Linux sans interface graphique, à savoir Debian dans sa version "Bullseye" (Debian 11). Sans celui-ci, il nous serait impossible de réaliser la moindre tâche avec notre serveur. Le fait qu'il s'agisse d'une distribution Linux va nous permettre de pouvoir manipuler les différents services autant que nous le souhaitons, avec un système de paquets très pratiques. Afin d'installer cette distribution, les administrateurs Systèmes et Réseaux nous ont mit à disposition un boot via le réseau. En temps normal pour installer un système d'exploitation, quel qu'il soit, les utilisateurs utilisent des clés USB ou un disque dur qui permette de démarrer sur celui-ci et d'installer le système d'exploitation à partir de la. Le principe est le même dans notre cas sauf que cette installation se fait par le réseau IEM qui est le réseau de l'université de Bourgogne. Pour lancer l'installation nous devions brancher notre serveur sur le réseau et le démarrer depuis le bios en sélectionnant le bouton "PXE IEM". Une fois l'installation démarrée nous devions suivre les étapes d'installation, telles que définir le nom et mot de passe du root, choisir/créer des partition du disque dur, donner un nom à la machine, ... 

\subsection{Partitions du disque}

Lors de l'installation du système d'exploitation il est nécessaire de réaliser des partitions du disque dur pour scinder son espace de mémoire afin d'être utilisé pour différentes choses en simultané et sans risque de collisions ou de chevauchements. Notre disque après l'installation est désormais composé de 3 partitions et il est possible de les afficher ainsi que des détails supplémentaires avec la commande:
\begin{lstlisting}[language=bash]
  $ sudo fdisk -l
\end{lstlisting}

 % partitionDisque.PNG: 1115x234 px, 96dpi, 29.51x6.19 cm, bb=0 0 836 176
\begin{figure}[!h]
\centerline{\includegraphics[width=15cm]{images/partitionDisque.PNG}}
\caption{Les 3 partitions d'un disque}
\label{fig1}
\end{figure}

Sur la figure \ref{fig1}, nous pouvons voir distinctement les différentes partitions, dont la partition générale sda1 de 237.5 Go qui nous permet de stocker différents fichiers tels que des paquets pour l'utilisation de Debian ou encore différents fichiers de configuration par exemple. De plus, nous pouvons voir la partition qui permet le mécanisme de swap. Il s'agit d'un mécanisme du système d'exploitation qui va se servir du disque dur pour stocker des informations normalement stockées dans la RAM, lorsque celle-ci est saturée. Il y a également un partition étendue qui est un conteneur de partitions logiques: sda2. Maintenant que Debian est installé sur notre routeur, il est prêt à être configuré et utilisé pour différentes tâches. 

\subsection{Synthèse des commandes du gestionnaire de paquets}
Sous Debian il existe de multiple gestionnaires de paquets, tels que aptitude, apt et dpkg. Dans notre cas, nous avons utilisé ``apt-get".
Il est important de comprendre que les outils de gestion des paquets Debian de plus haut niveau comme aptitude, apt-get ou synaptic reposent sur apt qui, lui-même, utilise dpkg pour la gestion des paquets sur le système.

\subsubsection{Mise à jour du système}
Il est possible de mettre à jour le système avec le gestionnaire de paquets ``apt-get", en étant connecté en tant que root ou en préfixant les commandes avec sudo. Auparavant, on utilise la commande ``update" qui permet d'actualiser la liste des paquets disponibles pour le système, à partir du dépôt de paquets. Le dépot de paquet est un service sur un serveur distant, contenant les fichiers des paquets à mettre à jour ou à installer. On lance la commande avant d'installer un nouveau paquet ou avant d'installer les mises à jour du système. Elle ne modifie pas le système, elle demande simplement s'il existe de nouveaux paquets ou des nouvelles versions de paquets. On utilise cette commande de cette façon en tant que root: 
\begin{lstlisting}[language=bash] 
    $ apt-get update
\end{lstlisting} 
Ou pour un utilisateur qui n'a pas tous les droits:
\begin{lstlisting}[language=bash] 
    $ sudo apt-get update
\end{lstlisting} 
Cette étape n'est pas nécessaire mais c'est un bon réflexe à avoir avant de mettre à jour tous les paquets.

S'il y a des paquets à mettre à jour, alors on peut utiliser la commande ``upgrade" pour les installer à partir des fichiers stockés sur les sources énumérées. De nouveaux paquets seront installés si cela est nécessaire, mais les paquets installés ne seront jamais supprimés.
\begin{lstlisting}[language=bash] 
    $ apt-get upgrade
        ou
    $ sudo apt-get upgrade
\end{lstlisting}

Afin de mettre à jour l'ensemble du système, il est possible d'utiliser ceci:
\begin{lstlisting}[language=bash] 
    $ apt-get dist-upgrade
\end{lstlisting}
Il est recommandé d'installer les dernières versions de paquets disponibles pour le système utilisé que ce soit Linux, Windows ou autres. Cela permet de corriger des bugs et d'installer des correctifs de sécurité.

\subsubsection{Les paquets}
Afin d'administrer correctement un système GNU/Linux Debian, voici une liste non exhaustive des commandes de gestion de paquets de Debian à connaître.

\begin{itemize}
\item
\begin{lstlisting}[language=bash] 
    $ apt-cache search <expression rationnelle> 
\end{lstlisting}
Pour rechercher un paquet il est possible d’utiliser la commande "search", cette dernière recherche un paquet à partir d’une expression rationnelle. La recherche porte sur le nom et la description du paquet.
 
\item
\begin{lstlisting}[language=bash] 
    $ apt-cache show <paquet> 
\end{lstlisting}
Pour afficher des informations détaillées concernant un paquet.

\item
\begin{lstlisting}[language=bash] 
    $ apt-cache policy <paquet>
\end{lstlisting}
Pour afficher les versions disponibles d'un paquet.

\item
\begin{lstlisting}[language=bash] 
    $ apt-get install <paquet>
\end{lstlisting}
L'installation d'un paquet disponible sur les serveurs, qui sera couramment utilisé durant nos installations.

\item
\begin{lstlisting}[language=bash] 
    $ apt-get remove <paquet>
\end{lstlisting}
Si nous avons besoin de désinstaller un paquet, on peut utiliser ceci. De plus, la désinstallation d'un paquet avec cette commande ne supprime pas les fichiers de configuration éventuel, ce qui permet de ne pas perdre sa configuration si on est amené à le réinstaller plus tard.

\item
\begin{lstlisting}[language=bash] 
    $ apt-get purge <paquet>
\end{lstlisting}
A contrario ici le paquet est désinstallé avec tous les fichiers de configuration.

\item
\begin{lstlisting}[language=bash] 
    $ apt-get autoremove
\end{lstlisting}
Supprimer les paquets installés automatiquement lorsqu'ils ne sont plus nécessaires.

\item
\begin{lstlisting}[language=bash] 
    $ apt-get clean
\end{lstlisting}
Nettoyer complètement le dépôt local des fichiers de paquets récupérés.

\item
\begin{lstlisting}[language=bash] 
    $ apt-get autoclean
\end{lstlisting}
Nettoyer le dépôt local des fichiers des paquets périmés.\\
 
Et il y a évidemment les différentes mises à jour vues précédemment.
\item
\begin{lstlisting}[language=bash] 
    $ apt-get update
    $ apt-get upgrade
    $ apt-get dist-upgrade
\end{lstlisting} 
\end{itemize}
Avec toutes ces commandes, nous sommes fin prêt à mettre en place tout un tas de service divers et variés tel qu'un DNS ou encore un serveur LAMP par exemple.

\section{Paramétrage du réseau}
Pour pouvoir commencer à communiquer entre différentes machines, nous avons ensuite défini la répartition des adresses IP pour chaque groupe (chaque agence) et paramétré en conséquences les différentes interfaces réseaux sur le routeur puis le client. Pour cela, nous nous sommes connectés au réseau IEM via la carte réseau intégré à la carte mère sur routeur, la première carte réseau externe a été branchée au switch afin de permettre la communication avec les autres groupes, donc le réseau d'interconnexion et dernièrement la deuxième carte réseau externe est utilisée pour le réseau privé mais puisque nous n'avons qu'un client, nous l'avons directement connecté. Toutes les connexions ont étés effectuées via des câbles Ethernet standard. Ici le but de la manipulation est de mettre en place un réseau d'entreprises et d'une infrastructure de services.

\subsection{Répartition des adresse IP (réseau d'Interconnexion entre agences et réseau privé de l'agence)}
Chaque binôme du groupe de TP s'est vu attribué une adresse IP de classe C et un masque qui sera utilisé pour le réseau d’interconnexion. Puisqu'il y a 5 binômes dans notre groupe de TP, nous avons pris une adresse dans la plage allant de 192.168.1.1 à 192.168.1.5. Pour la même raison, nous avons défini le masque du réseau d'Interconnexion à 255.255.255.248, résultat que nous avons obtenu en ajoutant 3 bits à 1 le plus à gauche possible au masque standard de classe C (255.255.255.0). Ces 3 bits supplémentaires nous permettent de coder 2\textsuperscript{3}=8  sous réseaux, ce qui suffit pour nos 5 groupes.
\newline
 % ReseauInterco&Prive.png: 720x310 px, 96dpi, 19.05x8.20 cm, bb=0 0 540 232
\begin{figure}[!h]
\centerline{\includegraphics[width=15cm]{images/ReseauInterco&Prive.png}}
\caption{Tableau des adresses IP de chaque groupe}
\label{fig2}
\end{figure}

\par
Le tableau de la figure \ref{fig2} récapitule les adresses IP allouées pour chaque réseau et pour chaque groupe. Pour notre cas nous sommes dans le groupe 2 ce qui signifie que notre adresse sur le réseau d’interconnexion est 192.168.1.2 et notre adresse de réseau privé est 10.1.2.0.
\newline
\par
Après avoir défini ces adresses et ces réseaux sur le papier, il est désormais temps de configurer les machines afin de les implémenter concrètement.

\subsection{Les interfaces réseaux du routeur}
Les adresses que nous venons de répartir entre chaque groupe et réseaux doivent être utilisées par le routeur. Nous allons donc maintenant expliquer comment nous avons paramétré les interfaces réseaux sur le routeur. Pour cela, nous avons travailler avec le fichier /etc/network/interfaces qui régis le fonctionnement des interfaces réseaux de la machine au niveau du noyau du système d'exploitation. Une interface réseau correspond à une carte réseau (en général) et il est possible à partir de son de la configurer (adresse statique, adresse du réseau, masque, gateway, ...). La gateway d'une telle configuration est la machine qui doit être utilisé pour passer d'un réseau à un autre. En d'autres termes, il s'agit de la "porte d'accès" à utiliser. Par exemple si une machine du réseau privé veut communiquer avec une autre machine située sur le réseau IEM, elle devra utiliser le serveur pour router ses paquets. Nous avons modifié le fichier pour obtenir le résultat de la figure \ref{fig3}. 

\begin{figure}[!h]
\centerline{ \includegraphics[width=15cm]{images/interfacesRouteur.png}}
\caption{Fichier de configuration des interfaces réseaux du routeur}
\label{fig3}
\end{figure}

Il est possible d'afficher les interfaces réseaux disponibles sur la machine dans le shell avec la commande:
\begin{lstlisting}[language=bash] 
    $ ip a 
\end{lstlisting} 
Cette commande a pour intérêt de nous faire connaître rapidement les adresses MAC et/ou IP de chaque interface. Elle nous a permit de connaître le nom des interfaces à utiliser dans notre fichier de configuration mais elle permet également de savoir si une interface est active "UP" ou pas "DOWN". En effet, durant les phases de tests il était important de savoir quelles interfaces étaient allumées ou éteintes. Il est possible qu'après une mauvaise configuration ou un problème, une interface soit éteinte. Il existe des commandes utilitaires pour les manipuler, l'une allumant l'interface nommée ``interface'' et l'autre l'éteignant. 

\begin{lstlisting}[language=bash] 
    $ ifup interface
    $ ifdown interface
\end{lstlisting}

Pour le fichier de configuration (figure \ref{fig3} ci-dessus) , nous pouvons voir que nous avons configuré les 3 interfaces (donc les 3 ports Ethernet que possède notre routeur), ainsi que l'interface ``lo" qui représente le loopback. Le loopback est la ``boucle'' locale: c'est une interface virtuelle qui permet de définir à une machine ``elle même'', notamment lors de l'utilisation de l'adresse ``localhost''.  Pour chacune des interfaces, nous avons donc défini leur adresse (address), leur masque (netmask) et leur réseau (network). Pour l'interface ``eno1" qui est relié au réseau IEM, nous avons plusieurs informations supplémentaire: l'adresse de broadcast (adresse utilisée pour transmettre un message à toutes les autres machines d'un réseau), la passerelle (gateway), les dns, ... Nous pouvons voir que l'interface ``eno1" est relier au réseau IEM car pour le réseau nous avons indiqué l'adresse 172.31.20.1 qui est l'adresse du routeur du réseau IEM fournie par les intervenants des travaux pratiques. Le raisonnement est le même pour les interfaces ``enp3s0" et ``enp1s0", pour lesquels nous avons indiqué respectivement pour le réseau les adresses 10.1.2.0 et 192.158.1.0. Il s'agit donc des réseaux d'interconnexion et privé. Les entrées "dns-nameservers" et "pre-up" seront expliquées plus en détail ultérieurement. Une fois le fichier de configuration des interfaces réseaux édité à notre souhait, ses informations ne sont pas prises en compte immédiatement: il est nécessaire de redémarrer le service réseau associé, en tant que root ou alors avec sudo:

\begin{lstlisting}[language=bash] 
    $ service networking restart
    ou
    $ /etc/init.d/networking restart
    ou
    $ systemctl restart networking
\end{lstlisting}
Ces 3 commandes permettent de façon similaire de redémarrer le service réseau. 
\newline
\par Cependant, ces configurations sur le routeur ne sont pas les seules nécessaires pour que tous les réseaux fonctionnent: il est également nécessaire de configurer la machine client qui est connectée au réseau privé, notamment pour qu'elle connaisse comment communiquer avec une machine du réseau d'interconnexion ou du réseau IEM.

\subsection{Les interfaces réseaux du client}

Nous allons maintenant expliquer comment nous avons paramétré les interfaces réseaux sur le client. De la même manière que pour le routeur, le fichier de configuration se trouve dans /etc/network/interfaces et sa forme est identique a celui du routeur. Cependant, cette fois il n'est nécessaire de configurer qu'une seule interface, la seule qui est utilisée et qui est connectée au routeur par le réseau privé. Les informations que nous retrouvons dans ce fichier sont les suivantes. On peut y retrouver l'adresse de la machine, le masque et le réseau, ainsi que la gateway.

\begin{lstlisting}[language=bash]
    auto enp11s0
    iface enp11s0 inet static
                address 10.1.2.2
                netmask 255.255.255.0
                network 10.1.2.0
                gateway 10.1.2.1
\end{lstlisting}

On voit ici que l'IP renseigné pour le réseau de l'interface ``enp11s0" est 10.1.2.1, qui est l'adresse de notre sous réseau. L'adresse IP de notre client est désormais fixée à 10.1.2.2.
Comme pour le routeur, afin d'appliquer les changements il faut redémarrer le service avec l'une des trois commandes évoquées précédemment. Par la suite, toutes ces configurations vont permettre au client et au routeur de communiquer avec le reste des machines des autres groupes. 

\subsection{Communication basique sans table de routage}

Nous allons maintenant aborder la communication entre différentes machines, car nous avons pour but de simuler un réseau en entreprise, et par conséquent il faut que nos machines puissent communiquer. Il est également nécessaire que le routeur soit en capacité de rediriger correctement les paquets des machines la où ils doivent être conduits. Par défaut, le client et le routeur peuvent communiquer car ils sont branchés physiquement entre eux. Il en est de même pour tous les routeurs qui sont branchés sur le réseau IEM car ils sont tous sur le même réseau. Afin de tester les communication entre différentes machines, que ce soit routeurs ou clients, nous pouvons essayer de ping la machine, à condition que le protocol soit activé sur la cible, avec cette commande:
\begin{lstlisting}[language=bash]
  $ ping ip_machine
\end{lstlisting}

Pour montrer le bon fonctionnement jusqu'ici, nous allons avec notre routeur, essayer de ping le routeur d'un autre groupe via le réseau IEM:

\begin{figure}[!h]
\centerline{ \includegraphics[width=15cm]{images/routeurPingRouteur.png}}
\caption{Ping de notre routeur à un autre}
\label{fig4}
\end{figure}

Nous pouvons voir sur la figure \ref{fig4} que les paquets sont bien envoyés et reçus par notre correspondant et tout s'est bien déroulé. Cependant si notre routeur ou notre client veut ping ou plus globalement communiquer avec un client d'un autre groupe qui est donc sur un autre réseau privé, nous allons devoir lui indiquer le chemin pour aller jusqu'à celui-ci, ce qui est réaliser avec un table de routage.

\subsection{Mise en place de la table de routage}

L'étape suivante est la création de routes afin de permettre la communication entre les différentes machines de la simulation: le client et le routeur, mais également entre chaque routeurs (les autres agences) et entre différents clients de différentes agences.
\par
Dans la configuration actuelle, il nous est impossible de ping le client qui est connecté ``derrière'' un autre routeur que le notre, car notre routeur ne connaîtra pas de chemin (route) par lequel acheminer les paquets vers cette cible. Pour arriver à faire ceci, il nous faut mettre en place une table de routage.
Il s'agit d'une table qui permet d'indiquer les routes possibles pour atteindre certains réseaux et avec une adresse de redirection dite de ``default'' qui indique vers qui envoyer le paquet si on ne connaît pas de chemin. Si aucun chemin n'est trouvé, l'erreur ``Network Unreachable'' sera renvoyé à l'émetteur du paquet. 

Il est possible d'afficher les routes de notre routeur dans le shell avec la commande:
\begin{lstlisting}[language=bash] 
    $ ip route
\end{lstlisting} 

\begin{figure}[!h]
\centerline{ \includegraphics[width=15cm]{images/routeRouteur.png}}
\caption{Route de notre routeur}
\label{fig5}
\end{figure}

Nous pouvons voir sur la figure \ref{fig5} que la route par défaut à emprunter pour tous les paquets qui arrivent, si aucune des routes décrites ne convient, est la route par l'adresse 172.31.20.1. Il s'agit de l'adresse du routeur du réseau IEM, qui va à son tour regarder dans ses tables (ou non si le destinataire est directement accessible) une route correspondante ou utiliser sa route par défaut et ainsi de suite. Nous pouvons également voir que les paquets à destination du réseau 10.1.2.0/24 sont dirigé vers l'adresse 10.1.2.1. Il s'agit de l'adresse de notre serveur mais sur le réseau privé: le paquet est donc routé par une autre interface afin d'atteindre le sous réseau privé de destination. Le principe est le même pour le réseau d'interconnexion, et le réseau IEM qui sont également redirigés vers d'autres interfaces sur le serveur mais qui sont toutes différentes. Pour finir, nous pouvons voir que le traffic n'ayant pas trouvé de route sera envoyé vers l'adresse du routeur du réseau IEM (route par défaut).
\newline
\par
Les routes statiques sont ajoutées dans le noyau de notre serveur par l'intermédiaire de la commande ip route, utilisée en tant que root ou avec sudo dans le cas contraire: 
\begin{lstlisting}[language=bash] 
    $ ip route add {network} via {IP}
\end{lstlisting}

Ces routes fonctionnent pour notre réseau privé, le réseau d'interconnexion ou le réseau IEM. Cependant, elles ne nous permettent toujours pas de communiquer avec un router connecté derrière le serveur d'un autre groupe. Pour cela,  il va nous falloir ajouter encore une route et de la même façon il nous faudra une route pour chaque groupe avec lequel nous souhaitons communiquer. Le groupe avec qui nous effectuons les tests ont pour adresse (leur serveur) sur le réseau d'interconnexion l'adresse IP 192.168.1.1 et pour adresse de leur réseau privé 10.1.1.0. L'adresse IP de leur client dans leur réseau privé est 10.1.1.1.
\newline
Pour pouvoir communiquer avec une machine sur leur réseau privé, nous devons donc appliquer sur notre routeur la commande : 
\begin{lstlisting}[language=bash] 
    $ ip route add 10.1.1.0/24 via 192.168.1.1
\end{lstlisting}
Cette commande permet de dire que tout ce qui est à destination de leur réseau privé, d'adresse IP 10.1.1.0, doit être redirigé vers la machine ayant l'adresse 192.168.1.1, c'est à dire leur routeur. Leur routeur sera alors atteint en empruntant le réseau d'interconnexion. Nous pouvons désormais, avec notre routeur, taper la commande qui permet de ping leur client:
\begin{lstlisting}[language=bash] 
    $ ping 10.1.1.1
\end{lstlisting}
Le ping du client de leur réseau privé fonctionne désormais: nos paquets sont bien envoyés et réceptionnés. 

\subsection{Règles iptables pour laisser l'accès a internet a une machine}

L'architecture de notre réseau commence à prendre forme, mais un client sur notre réseau privé ne peut toujours pas accéder à internet: pour le moment seul le routeur est connecté à internet à travers le réseau IEM. Pour réaliser cette manoeuvre appelée une translation d'adresse, nous allons utiliser les règles "iptables":

\begin{lstlisting}[language=bash] 
    $ iptables -t nat -A POSTROUTING -s 10.1.2.0/24 
    -o eno1 -j MASQUERADE
\end{lstlisting}

Cette commande permet d'indiquer au routeur qu'il doit retransmettre les paquets reçus du réseau privé (source 10.1.2.0/24) sur le réseau IEM (interface de sortie "eno1"). L'option masquerade permet d'indiquer que le paquet sera retransmis par translation d'adresse, c'est à dire que le routeur va stocker dans son noyau les informations sur l'émetteur de ce paquet (adresse, port, ...) puis va l'émettre à nouveau en son nom. Lorsque le routeur recevra une réponse, il pourra consulter la table de translation dans son noyau pour trouver à qui il doit transférer le paquet.
\newline
\par
Afin de vérifier si notre routeur était capable d'utiliser internet, nous avons installé "links2" qui a été auparavant installé via le gestionnaire de paquet "apt". Il s'agit d'une commande qui permet de consulter des pages web avec un affichage non graphique, que nous utilisons avec la commande: 
\begin{lstlisting}[language=bash] 
    $ links2 google.com
\end{lstlisting}
Et en effet, notre routeur était capable de surfer sur le web. Nous avons également appliqué cette procédure pour notre client afin de vérifier si il était connecté à internet.
\newline\newline
\par
L'inconvénient de cette nouvelle règle iptable est que n'importe quel client qui arrive à se connecter au réseau privé peut avoir accès à toutes les ressources et se connecter au réseau IEM ou d'interconnexion. Nous pouvons restreindre l'accès à notre réseau privé en n'attribuant une adresse IP qu'à certaines adresses MAC connues, via le service DHCP.

\section{Service DHCP}
Maintenant partons du principe que nous souhaitons connecter plusieurs clients sur notre réseau privé, il est alors important d'approfondir le paramétrage de notre réseau avec la mise en place d'un service DHCP afin de définir les adresses IP à attribuer pour les machines (clients) se connectant sur notre réseau privé.
\subsection{Mise en place du DHCP}

Avant toute chose, nous avons cherché et installé le bon paquet pour l'utilisation du DHCP:
\begin{lstlisting}[language=bash] 
    $ apt-get install isc-dhcp-server
\end{lstlisting}
Une fois l'installation effectuée, nous nous sommes rendu dans le fichier /etc/default/isc-dhcp-server qui a été installé avec le paquet via la commande décrite précedemment. Dans ce fichier de configuration, il faut renseigner avec quelle interface réseau nous voulons travailler pour la suite de la mise du DHCP.

\begin{figure}[!h]
\centerline{\includegraphics[width=15cm]{images/dhcpServeur.png}}
\caption{Interface du DHCP}
\label{fig6}
\end{figure}

Puisque nous voulons allouer automatiquement l'adresse IP de chaque client connecté à notre réseau privé nous avons utilisé l'interface ``enp3s0", qui est celle utilisée pour notre réseau privé. Nous travaillons uniquement en IPv4 donc nous avons laissé vide les interfaces pour IPv6.
\newline
\par
Ceci étant fait, nous pouvons désormais passer au paramétrage en détails du serveur DHCP, comme par example la plage d'adresse IP qui va être subnetée, ou encore fixer des adresses IP pour des postes ayant des adresses MAC définies. Cette configuration du serveur DHCP se fait sur le fichier ``/etc/dhcp/dhcpd.conf".

\begin{figure}[!h]
\centerline{ \includegraphics[width=15cm]{images/dhcpdConfServeur.png}}
\caption{Configuration du serveur DHCP}
\label{fig7}
\end{figure}

Sur la figure \ref{fig7} nous pouvons voir que le réseau subneté est notre réseau privé ayant comme adresse 10.1.2.0 et le masque 255.255.255.0. Nous attribuons une adresse fixe à plusieurs clients car durant nos tests il est arrivé que nous ayons des clients différents et sans cela, il aurait été impossible pour le cient de se connecter au réseau privé. Afin d'attribuer une adresse fixe, il suffit d'indiquer l'adresse qu'on lui fixe avec comme entrée ``fixed-address" ainsi que son adresse MAC ``hardware ethernet".
Nous avons également renseigné différentes informations concernant le DNS mais nous aborderons le sujet plus tard.

De la même façon que pour les interfaces réseaux, quand une modification est apportée il faut redémarrer le service correspondant afin de prendre en compte les changements effectués, avec la commande:

\begin{lstlisting}[language=bash] 
    $ service isc-dhcp-server restart
\end{lstlisting}

Il est également possible de démarrer le service, si il est arrêté, avec:
\begin{lstlisting}[language=bash] 
    $ service isc-dhcp-server start
\end{lstlisting}
Ou a contrario nous pouvons le stopper si besoin avec:
\begin{lstlisting}[language=bash] 
    $ service isc-dhcp-server stop
\end{lstlisting}
Il est également possible d'afficher les erreurs en cas de soucis avec:
\begin{lstlisting}[language=bash] 
    $ cat /var/log/syslog
\end{lstlisting}
Et finalement on peut afficher l'interface d'écoute du démon par l'intermédiaire de la commande:
\begin{lstlisting}[language=bash] 
    $ ps ax | grep dhcpd
\end{lstlisting}
En cas de problème ou pour simplement monitorer ce qu'il se passe sur notre serveur, il peut être intéressant de garder une trace de ce qu'il se passe avec le service. Pour cela, nous avons besoin de mettre un place un système de logs dans notre DHCP.

\subsection{Système de logs pour le DHCP}
TODO
\section{Sauvegarde automatique}
\subsection{Rsync}
Les fichiers importants tels que les logs ou les données sont souvent sauvegardés afin de pouvoir les récuperer en cas de problèmes. Pour mettre en place une telle sauvegarde, nous avons utilisé un paquet nommé ``rsync" qui permet la synchronisation de fichiers. De plus, il est utilisé pour mettre en place des systèmes de sauvegardes distantes ou de points de restauration du système, ce qui est parfaitement ce que nous cherchons pour notre serveur.
La commande de base pour utiliser rsync se fait par :
\begin{lstlisting}[language=bash] 
    $ rsync source/ destination/
\end{lstlisting}
Cette commande va sauvegarder tous les fichiers d'un répertoire source dans un autre répertoire destination.
Cependant, dans notre cas nous allons pousser un peu plus loin et utiliser SSH afin de synchroniser nos fichiers à distance sur une autre machine. Le protocole SSH permet d'établir une communication chiffrée entre une machine locale (le client) et une machine distante (le serveur). Pour utiliser SSH, il est nécessaire de l'installer via le gestionnaire de paquets, et le paramétrer via les commandes :
\begin{lstlisting}[language=bash] 
    $ sudo apt install openssh-serveur
    $ ssh-keygen
    $ ssh-copy-id -i ~/.ssh/id_rsa.pub etudiant@10.1.2.2
\end{lstlisting}   
Comme expliqué précédemment, une fois l'installation de SSH terminée, il nous faut générer une paire de clé public et privée d'authentification (ssh-keygen) qui vont être enregistrés dans les fichiers ``/.ssh/id\_rsa" pour la clé privée et "/.ssh/id\_rsa.pub" pour la clé public. Une fois les clés générées avec succès, nous allons les utiliser pour se connecter en SSH à notre client. La commande ssh-copy-id facilite la connexion par clé SSH, ce qui supprime le besoin d'un mot de passe pour chaque connexion. Une fois la connexion au client correctement configuré, on peut l'utiliser avec rsync afin de sauvegarder les fichiers que nous voulons sur le client. Voici la manipulation de base à effectuer: 
\begin{lstlisting}[language=bash] 
    $ rsync -avz -e ssh chemin/source/ 
        user@ip:"/chemin de destination/"
\end{lstlisting}   
Et dans notre cas nous utilisons précisement:
\begin{lstlisting}[language=bash] 
    $ rsync -avz -e ssh /etc 
        etudiant@10.1.2.2:/home/etudiant/Bureau/backup/
\end{lstlisting}   
Le serveur est capable dorénavant de sauvegarder l'ensemble de sont répertoire "/etc" dans le répertoire "/home/etudiant/Bureau/backup/" de notre client, simplement via l'utilisation de rsync par SSH. Mais il est encore plus intéressant de se demander comment automatiser totalement cette sauvegarde. 

\subsection{Cron}
Dans le monde de l'informatique, l'automatisation de tâches est très souvent recherchée pour gagner du temps et ne plus s'occuper des tâches automatisées. C'est pour cette raison que nous allons utiliser en plus de rsync et SSH un programme nommé ``cron". Cron est un programme qui permet d'exécuter automatiquement des scripts, des commandes ou des services à une date et une heure spécifiée précise, ou selon un cycle défini à l’avance. Cron est parfois appelé ``gestionnaire de tâches planifiées" ou ``planificateur de tâches". Chaque utilisateur à un fichier crontab, lui permettant d'indiquer les actions à exécuter et leur fréquence. Dans notre cas nous allons utiliser le fichier crontab de l'utilisateur ``root".
La commande : 
\begin{lstlisting}[language=bash] 
    $ crontab -e 
\end{lstlisting}   
est utilisée afin d'éditer les actions grâce au fichier crontab, qui s'ouvre après avoir défini un éditeur de texte à utiliser la première fois qu'on lance cette commande.
Dans le fichier crontab, nous allons renseigner cette ligne qui reprend ce qui a été expliqué précédemment avec rsync et SSH : 
\begin{lstlisting}[language=bash] 
        0 15 * * * rsync -avz -e ssh /etc 
            etudiant@10.1.2.2:/home/etudiant/Bureau/backup/
\end{lstlisting}   
Mais nous y ajoutons cette fois ``0 15 * * *", qui veut dire que nous allons appliquer le principe de rsync et SSH tous les jours de tous les mois à 15h et 0 minute. En effet, le premier paramètre indique les minutes comprises entre 1 et 60, le second indique les heures de 1 à 24, le troisième est pour les jours dans le mois donc de 1 à 31. Et les deux derniers sont pour les mois et jours de la semaines compris entre 1 à 12 pour les mois et 1 (lundi) et 7 (dimanche) pour les jours.

Pour examiner les tâches planifiées de l'utilisateur courant (le contenu du fichier crontab), on peut utiliser:
\begin{lstlisting}[language=bash] 
    $ crontab -l
\end{lstlisting} 
Ce qui nous affiche :
\begin{figure}[!h]
\centerline{ \includegraphics[width=15cm]{images/rsync&crontab.png}}
\caption{Contenue du fichier crontab.}
\label{fig8}
\end{figure}
\\\\

La mise en place de notre réseau d'entreprise et d'infrastructure est terminée. Pour rappel, nous avons installé une distribution Linux, puis paramétré les bases de notre réseau. Ensuite, nous avons mis en place un service DHCP et finalement une sauvegarde automatique. Nous allons désormais étendre notre réseau et mettre en place un serveur de nom de domaine (DNS). Mais avant de mettre en place le DNS, il faut regarder comment il fonctionne.

\section{Interrogation d'un serveur DNS}
Avant toute installation, nous avons commencé par comprendre le fonctionnement du DNS. En effet, le DNS (pour Domain Name Serveur en anglais) est un service informatique distribué. Il est utilisé pour traduire les noms de domaine sur Internet avec leurs adresse IP ou autres enregistrements. Pour faire simple, le serveur DNS est un service qui permet d'associer à un site web (ou un ordinateur connecté ou un serveur) une adresse IP. Cette traduction peut se faire dans les 2 sens: trouver une IP à partir d'un nom de domaine mais également de retrouver le nom de domaine à partir de l'IP. Pour la suite de notre installation le DNS va être un composant important de notre réseau. Il est important de rappeler que tous les équipements connectés à un réseau IP, comme Internet, possèdent une adresse IP qui les identifie sur le réseau.

\subsection{Les commandes host, dig et nslookup}
Les serveurs DNS que nous allons interroger ont pour but de montrer les informations qu'il contiennent et ainsi comprendre les bases. Les serveurs DNS que l'on a interrogé durant nos tests, sont interrogés via les commandes : host, dig et nslookup.

La commande host renvoie l’adresse IP et l'adresse MAC associées au nom de domaine, on l'utilise comme ceci
\begin{lstlisting}[language=bash] 
    $ host {nom}
\end{lstlisting} 

Nous l'avons testé avec:
\begin{lstlisting}[language=bash] 
    $ host www.debian.org
\end{lstlisting} 

Qui nous a retourné ceci:
\begin{figure}[H]
\centerline{ \includegraphics[width=15cm]{images/hostDebian.png}}
\caption{Exemple d'interrogation d'un DNS avec host.}
\label{fig9}
\end{figure}

Sur l'image \ref{fig9}, 2 informations importantes sont données: l'adresse IP du site sur la première ligne avec comme valeur: ``130.89.148.77", et l'adresse MAC sur la seconde: ``2001:67c:2564:a119::77". Voila ce que nous ressort la commande host, voyons maintenant avec dig.
\newline
\par
Dig est également un utilitaire en ligne de commande qui effectue une recherche DNS en interrogeant des serveurs de noms, et on l'utilise de cette façon: 
\begin{lstlisting}[language=bash] 
    $ dig {nom}
\end{lstlisting} 

Nous l'avons testé avec:
\begin{lstlisting}[language=bash] 
    $ dig www.debian.org
\end{lstlisting} 

Qui nous a indiqué:
\begin{figure}[H]
\centerline{ \includegraphics[width=15cm]{images/digDebian.png}}
\caption{Exemple d'interrogation d'un DNS avec dig.}
\label{fig10}
\end{figure}

Cette fois sur l'image \ref{fig10}, nous obtenons d'avantages d'informations sur le DNS interrogé. Les lignes commençant par ";" sont des commentaires. La première ligne nous indique la version de la commande dig (9.16.22). Dans l’en-tête nous pouvons voir si une réponse a été reçue (ANSWER: 1), afin de savoir si le DNS a répondu ou non. Ensuite la section "QUESTION", nous indique simplement la requête, qui dans ce cas est une requête pour l’enregistrement ``A" de www.debian.org. IN signifie qu’il s’agit d’une recherche Internet. La section "ANSWER" nous indique que www.debian.org a l’adresse IP ``130.89.148.77". Enfin, il y a quelques statistiques supplémentaires sur la requête, comme la date ou la taille du paquets qui contenait le message.

L’utilitaire nslookup (Name System Look Up) est, tout comme les deux autres, un outil qui permet d’interroger directement un serveur de noms et d’en obtenir les informations concernant un domaine. On peut l'utiliser comme ceci: 
\begin{lstlisting}[language=bash] 
    $ nslookup {nom}
\end{lstlisting} 

Nous l'avons testé avec: 
\begin{lstlisting}[language=bash] 
    $ nslookup www.debian.org
\end{lstlisting} 

Qui nous a donc retourné:
\begin{figure}[H]
\centerline{ \includegraphics[width=15cm]{images/nslookupDebian.png}}
\caption{Exemple d'interrogation d'un DNS avec nslookup.}
\label{fig11}
\end{figure}

Finalement on observe sur l'image \ref{fig11}, que nslookup est à mis chemin entre dig et host. En effet, il nous affiche le serveur qui à interrogé le DNS, et la réponse du DNS en question avec son nom, son adresse IP et son adresse MAC, comme dig mais en plus synthétique. En règle générale avec nslookup nous avons toutes les informations nécessaire.

Que se soit pour host, dig ou encore nslookup, l'indication "{nom}" indique l’adresse IP ou le nom d’hôte du serveur à interroger. Cependant, ils sont utilisables avec d'autres paramètres, comme nous allons le voir juste après.\\\\

L'option "ns" est pour "nameserveur", cela permet d'indiquer où aller (à qui demander) pour trouver l'adresse IP d'un domaine. En effet, le mécanisme consistant à trouver l'adresse IP correspondant au nom d'un hôte est appelé "résolution de nom de domaine". L'application permettant de réaliser cette opération est appelée en anglais "resolver". Lorsqu'une application souhaite se connecter à un hôte connu par son nom de domaine (par exemple "www.debian.org"), celle-ci va interroger un serveur de noms défini dans sa configuration réseau.\\

Voici les différentes requêtes que nous avons essayé: 
\begin{lstlisting}[language=bash] 
    $ host -t ns www.debian.org
    $ dig www.debian.org ns
    $ dig debian.org ns
    $ dig org ns
    $ dig . ns
\end{lstlisting} 

Voyons en détails les réponse renvoyé par la ligne 1 et 2. 
\begin{figure}[H]
\centerline{ \includegraphics[width=15cm]{images/hostDebianNS.png}}
\caption{Requête de nameserveur pour un DNS avec host.}
\label{fig12}
\end{figure}

\begin{figure}[H]
\centerline{ \includegraphics[width=15cm]{images/digDebianNS.png}}
\caption{Requête de nameserveur pour un DNS avec dig.}
\label{fig13}
\end{figure}
Nous pouvons immédiatement constater que nous avons interrogé le même DNS afin de comparer les réponses. Comme expliqué précèdement, dig renvoient beaucoup plus de détails sur la requête que host. On observe principalement que la réponse des 2 commandes est identique, mais pour une requête qui aurait besoin de passer par beaucoup plus de nom de domaine, la commande dig serait plus intéressante. En effet, avec dig il est possible d'avoir le nombre de réponses obtenues; ici ``ANSWER: 3" pour ``geo1.debian.org", ``geo2.debian.org" et ``geo3.debian.org". 

Pour conclure, une requête est ainsi envoyée au premier serveur de noms (appelé "serveur de nom primaire"). Si celui-ci possède l'enregistrement dans son cache, il l'envoie à l'application. Dans le cas contraire, il interroge un serveur racine. Le serveur de nom racine renvoie une liste de serveurs de noms faisant autorité sur le domaine. Le serveur de noms primaire faisant autorité sur le domaine va alors être interrogé et retourner l'enregistrement correspondant à l'hôte sur le domaine: dans le cas présent les serveurs ``geo1.debian.org", ``geo2.debian.org" et ``geo3.debian.org". 

Finalement, nous pouvons conclure que dig et host renvoie les informations nécessaires identiques, host reste tout de même limité en informations tandis que dig est davantage détaillé. Les 2 commandes peuvent servir, tout dépend du niveau de détails dont on a besoin. 

\subsection{Fichier de renseignement du serveur DNS}
Sur notre serveur, le serveur DNS à utiliser doit être indiqué dans le fichier système: ``/etc/network/interfaces". C'est le même fichier qui renseigne les interfaces réseau. Ce fichier a déjà été évoqué précédemment, mais pas dans sa totalité. En effet, il est temps d'expliquer la ligne suivante: 
\begin{lstlisting}[language=bash] 
    $ dns-nameserveur 172.31.21.35 193.50.50.6
\end{lstlisting}
Cette ligne indique les 2 serveurs de noms de domaine que le système doit utiliser. En réalité le DNS avec l'adresse ``172.31.21.35" est le serveur DNS primaire du réseau IEM, et le DNS avec l'adresse ``193.50.50.5" est le serveur DNS secondaire du réseau IEM. Ces informations sont traités par le ``resolver" qui a été évoqué dans la partie précédente. 

\subsection{Rôle du fichier /etc/hosts}
Ce fichier, existant depuis le début des années 80, a pour rôle d'associer une adresse IP à un nom d'hôte (un nom de domaine n'étant qu'une forme structurée de nom d'hôte). Il est donc présent dans le répertoire ``/etc" et est consulté par le système à chaque fois qu'il accède à un nom d'hôte spécifique. Notons qu'il est consulté avant qu'une requête soit envoyée à un DNS. Aucune autre machine de notre réseau (même local) ne prendra en compte ce qui y est écrit dans celui-ci. Son utilisation est restreinte à de petits réseaux locaux ainsi qu'à quelques autres cas particuliers.

\section{Installation d'un DNS}

Pour la suite des explications, il est important de préciser que nous avons choisi comme nom de domaine: agence.atlantide.

\subsection{Mise en place du DNS}

Reparler du "dhcpd.conf".
Création des deux zones, (named.conf.local et named.conf.default-zone), copie du fichier "db.local" en "deb.agence.atlantide", copie de "db.127" en "db.agence.atlantide.inv" pour la zone de recherche inversé. Ajout des forwarders dans "named.conf.options". Redémarrage avec systemctl restart bind 9. Changement du dhcp pour prendre en compte le serveur DNS.
"option domain-name "agence.atlantide" fournit le nom de domaine, dans ce cas il sert a faire référence aux ordinateurs du réseau par leurs nom sans ajouter le nom de domaine.

Dans /etc/resolv.conf
\begin{figure}[!h]
\centerline{ \includegraphics[width=15cm]{images/resolvConf.png}}
\caption{Contenue du fichier de configuration de resolv.}
\label{fig100}
\end{figure}

Dans /etc/bind/named.conf.local
\begin{figure}[!h]
\centerline{ \includegraphics[width=15cm]{images/namedConfLocal.png}}
\caption{Contenue du fichier de configuration local de named.}
\label{fig101}
\end{figure}

Dans /etc/bind/named.conf.options
\begin{figure}[!h]
\centerline{ \includegraphics[width=15cm]{images/namedConfOptions.png}}
\caption{Contenue du fichier de configuration des options de named.}
\label{fig102}
\end{figure}

\subsection{Test réaliser afin de valider le DNS}
named-checkzone et named-checkconf pour vérifier la syntaxe
/var/log/syslog pour voir les erreurs si présente au démarrage
depuis le serveur : nslookup ip-client
depuis le serveur : nslookup nom-client
depuis un client connecté en filaire au routeur : nslookup ip-client
depuis un client connecté en filaire au routeur : nslookup nom-client
vers le serveur d'une autre agence : 
vers le client d'une autre agence :

Conclusion tp 1bis

Introduction tp 2

\section{Installation d'un serveur LAMP}
\subsection{Installation et mise en place d'Apache}

Test, localisation de la page web, création du compte utilisateur développeur, modification du serveur pour que www soit associé au dev web (crée dabs /srv), les bon droits, mise en place du virtuals hosts pointant sur /srv/www 

\subsection{Installation et mise en place de PostgreSQL}

Déroulement...

\subsection{Installation et mise en place de PHP}

Programme PHP qui se connecte a PostgreSQL et affichage infos pour la vérification.

\subsection{Installation et mise en place de MySQL}

Comme pour PostgreSQL et php

\subsection{Installation et mise en place d'un PDO}

\section{Script de routage et matrice de filtrage}
\subsection{Scripts de routage au démarrage}
\subsection{Règles iptables de la matrice de filtrage}


Conclusion tp 2

Introduction 3

\section{}
\subsection{}
\subsection{}

Conclusion tp 3

\section{Conclusion}
\section{Annexe}
\listoffigures  
\end{document}
