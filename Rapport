\documentclass[a4paper,10pt]{article}
%\documentclass[a4paper,10pt]{scrartcl}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{hyperref}

\title{Rapport Systèmes et Réseaux II}
\author{Perion Maxence, Pinon Alexandre}
\date{}

\renewcommand*\contentsname{Sommaire}

\pdfinfo{%
  /Title    ()
  /Author   ()
  /Creator  ()
  /Producer ()
  /Subject  ()
  /Keywords ()
}

\begin{document}

\maketitle 
\tableofcontents

\newpage
\section{Introduction}
L'objectif de ces Travaux Pratiques a été de réaliser un serveur complet pour une agence fictive. Pour cela, nous étions en possession de deux machines: un serveur/routeur ainsi qu'un client, une machine simulant la connexion d'un appareil au réseau de l'agence. Nous sommes partis de zéro et dans un premier temps nous avons installé Debian sur notre serveur, une distribution GNU/Linux, sans interface graphique via le réseau IEM pour avoir un outil de travail. Premièrement, nous avons défini et paramétré notre adressage et routage, c'est à dire la façon d'attribuer les adresses IP et comment communiquer sur les différents réseaux. Afin de s'affranchir des adresses IP et pour s'approcher d'un cadre plus réaliste, nous avons deuxièmement mis en place sur le serveur un service de DNS, permettant d'utiliser des noms de domaines agissant comme des alias pour des adresses IP.  Troisièmement, nous avons mis en place ce qui pourrait servir pour héberger un site web pour notre agence grâce à une suite d'outils appelée un LAMP. Pour finir, nous avons mis en place un service d'authentification centralisé LDAP ainsi qu'un service de partage de fichiers Samba.

\section{Installation d'une distribution GNU/Linux sans interface graphique}

\subsection{Installation via le réseau}

La première étape pour commencer à travailler a tout simplement était d'installer une distribution Debian GNU/Linux sans interface graphique. En effet cette distribution est un système d'exploitation et va nous permettre pour la suite des manipulations d'avoir une base de travail. Afin d'installer cette distribution les administrateurs système et réseau nous on mit à disposition un boot via le réseau. En temps normal pour installer un système d'exploitation qu'elle qu'il soit, les utilisateurs lambda utilisent des clés USB ou disque dur qui permette de boot sur celle-ci. Le principe est le même sauf que cette installation se fait par le réseau IEM qui est le réseau de l'université de Bourgogne. Pour lancer l'installation nous devions brancher notre serveur sur le réseau et la démarrer depuis le bios en sélectionnant le bouton "PXE IEM". Une fois l'installation démarrée nous devions suivre les étapes d'installation, tel que le nom et mot de passe du root, la choix des partition du disque, le nom de domaine (sartre.iem)... 
Le disque est composé de 3 partitions, il est possible d'afficher les partitions et des détails supplémentaire avec la commande :

\begin{lstlisting}[language=bash]
  $ sudo fdisk -l
\end{lstlisting}

\begin{center}
 \includegraphics[width=22cm, height=6cm]{images/partitionDisque.PNG}
 % partitionDisque.PNG: 1115x234 px, 96dpi, 29.51x6.19 cm, bb=0 0 836 176
 \underline{Les 3 partitions d'un disque.}
\end{center}

Ici nous pouvons voir distinctement les différentes partition. Dont la partition général de 237.5 Go qui permet de stocker différentes chose tel que des paquets pour l'utilisation de Debian ou encore différents types de fichiers. De plus nous pouvons voir la partition qui permet l'échange entre Linux et Solaris, mais également un partition étendue qui est un conteneur de partition logiques.
Maintenant que Debian est installé sur notre routeur il est prêt à être configuré et utilisé pour différentes tâches. 

\section{Paramétrage du réseau}
Nous avons ensuite définis la répartition des adresses IP pour chaque groupe (chaque agence) et paramétré en conséquences les différentes interfaces réseaux sur le routeur puis le client.
Avant tout paramétrage il est important de préciser que nous avons branché le réseau IEM sur la carte réseau intégré à la carte mère sur routeur. La première carte réseau externe à était branchée au switch afin de permettre la communication avec les autres groupes. Dernièrement la deuxième carte réseau externe est branchée sur le client. Ici le but de la manipulation est de mettre en place un réseau d'entreprises et d'une infrastructure de services.

\subsection{Répartition des adresse IP (réseau Interconnexion et réseau privé)}
Chaque groupe de TP possède une IP et un masque de classe C pour le réseau d’interconnexion. Afin de mettre en place le réseau d’interconnexion nous avons pris une plage IP compris entre 192.168.1.1 et 192.168.1.5 avec ce masque 255.255.255.248, 248 car nous avions besoin de 3 bits pour définir l'ensemble des routeurs qui sont dans le sous-réseau. En effet nous voulions distribuer les IP pour 6 routeurs, 5 pour les groupes de TP et 1 pour le réseau d’interconnexion.
\begin{center}
 \includegraphics[width=16cm, height=6cm]{images/ReseauInterco&Prive.png}
 % ReseauInterco&Prive.png: 720x310 px, 96dpi, 19.05x8.20 cm, bb=0 0 540 232
 \underline{Tableau des adresses IP de chaque groupe.}
\end{center}

Ce petit tableau récapitule les adresses IP allouer pour chaque réseau et pour chaque groupe. Pour notre cas nous sommes dans le groupe 2 ce qui veut dire que notre adresse sur le réseau d’interconnexion est le "192.168.1.2" et notre adresse de réseau privé est le "10.1.2.0".

\subsection{Interfaces réseau du routeur}
Les adresses que nous venons de répartir entre chaque groupe doivent être utiliser par le routeur. C'est pour cela que nous allons maintenant expliquer comment nous avons paramétré les interfaces réseau sur le routeur. Pour cela il suffit simplement de se rendre dans le fichier /etc/network/interfaces et de modifier le fichier comme ceci : 
\begin{center}
 \includegraphics[width=16cm, height=6cm]{images/interfacesRouteur.png}
 % ReseauInterco&Prive.png: 720x310 px, 96dpi, 19.05x8.20 cm, bb=0 0 540 232
 \underline{Fichier de configuration des interfaces réseaux du routeur.}
\end{center}

Il est également possible d'afficher les interfaces réseaux dans le shell avec la commande :
\begin{lstlisting}[language=bash] 
    $ ip a 
\end{lstlisting} 
ce qui a pour intérêt de connaître rapidement les macs adresse et/ou IP de chacun, mais permet également de savoir si une interface est en route "UP" ou pas "DOWN". En effet durant les phases de test il était important de savoir qu'elle interfaces était allumée ou éteinte, il nous est arrivé de relancer une interface à la main via la commande 

\begin{lstlisting}[language=bash] 
    $ ip link set enp3s0 up
\end{lstlisting}

Pour le fichier de configuration ci-dessus nous pouvons voire les 3 interfaces donc les 3 port Ethernet que possède notre routeur, ainsi que l'interface "lo" qui représente le loopback. Pour chacune d'entre elle leurs adresses (address), leurs masques (netmask) et leurs réseaux (network) sont indiqué. Pour l'interface "eno1" qui est relié au réseau IEM, nous avons plusieurs information supplémentaire ; l'adresse de broadcast ainsi que la passerelle (gateway). De plus nous pouvons maintenant différencier clairement qu'elle interface fait référence a qu'elle utilisation. En effet l'interface "eno1" est relier au réseau IEM car pour le réseau nous avons indiqué l'adresse "172.31.20.1" qui est l'adresse du routeur du réseau IEM fournie par les intervenants de travaux pratiques. Le raisonnement est le même pour les interfaces "enp3s0" et "enp1s0", pour lesquels nous avons indiquer respectivement pour le réseau "10.1.2.0" et "192.158.1.0". Et qui sont donc les réseaux d'interconnexion et privé. Les informations "dns-nameservers" et "pre-up" seront expliqué ultérieurement. Le fichier de configuration des interfaces réseaux est actuellement écrit et prêt a l'emploie, mais ce n'est pas pour autant que les interfaces vont changer. En effet pour que les modifications soit prise en compte il faut redémarrer le service associer en tant que root ou alors avec sudo :

\begin{lstlisting}[language=bash] 
    $ service networking restart
    ou
    $ /etc/init.d/networking restart
    ou
    $ systemctl restart networking
\end{lstlisting}
Ces 3 commandes permette de redémarrer le service qui s'occupe des interfaces réseaux. 

\subsection{Interfaces réseau du client}

Nous allons maintenant expliquer comment nous avons paramétré les interfaces réseau sur le client. Comme pour le routeur le fichier de configuration se trouve dans /etc/network/interfaces.
Par conséquent la forme du fichier est similaire a celui du routeur. Voici les informations que nous retrouvons sur le fichier et qui renseigne l'adresse, le masque et le réseau de l'interface réseau de notre client. 

\begin{lstlisting}[language=bash]
    auto enp11s0
    iface enp11s0 inet static
                address 10.1.2.2
                netmask 255.255.255.0
                network 10.1.2.0
                gateway 10.1.2.1
\end{lstlisting}
On voit ici que l'IP renseigné pour le réseau donc le network pour l'interface "enp11s0" est "10.1.2.1", qui est l'adresse du de notre sous réseau. On connais désormais l'IP de notre client qui est "10.1.2.2".
Comme pour le routeur afin d'appliquer les changements il faut redémarrer le service avec l'une des trois commande donnée pour le routeur. Par la suite toutes ces configuration vont permettre aux client et routeur de communiquer avec le reste des groupes. 

\subsection{Communication sans table de routage}

Nous allons maintenant aborder la communication entre différente machine, car en effet nous avons pour but de simuler un réseau en entreprise, et par conséquent il faut que nos machines puisse communiquer, et que le routeur puis rediriger correctement les machines ou elle souhaite aller en fessant office de filtre. Par défaut le client et le routeur peuvent communiquer car il sont branché physiquement entre eux. Il en est de même pour tous les routeurs qui sont brancher sur le réseau IEM. Afin de tester les communication entre différentes machines, que se soit routeurs ou clients, il nous suffit simplement de ping la machine avec sont IP et avec cette commande : 
\begin{lstlisting}[language=bash]
  $ ping ip_machine
\end{lstlisting}

Par exemple avec notre routeur nous allons ping le routeur d'un groupe d'amis via le réseau IEM :
\begin{center}
 \includegraphics[width=16cm, height=6cm]{images/routeurPingRouteur.png}
 % ReseauInterco&Prive.png: 720x310 px, 96dpi, 19.05x8.20 cm, bb=0 0 540 232
 \underline{Ping de notre routeur à un autre.}
\end{center}

Nous pouvons voir ici que les paquets sont bien envoyé et reçu par notre correspondant. Donc pas de soucis pour ping un autre routeur. Mais si notre routeur ou notre client veut ping ou plus couramment communiquer avec un client d'un autre groupe qui est donc sur un réseau privé, on va devoir lui indiquer le chemin pour aller jusqu'à celui-ci.

\subsection{Mise en place de la table de routage}

L'étape suivante est la création de routes afin de faire communiquer les différentes machines de la simulation: le client et le routeur, mais également entre chaque routeurs (les autres agences) et entre différents clients de différentes agences.
Dans la configuration actuelle il nous est impossible de ping le client qui passe par un autre routeur que le notre, en effet pour arriver a faire ceci il nous faut mettre en place une table de routage.
La table de routage permet d'indiquer les routes a prendre par tel ou tel machines. 
\begin{center}
 %\includegraphics[width=16cm, height=6cm]{images/???.png}
 % ReseauInterco&Prive.png: 720x310 px, 96dpi, 19.05x8.20 cm, bb=0 0 540 232
 \underline{Route de notre routeur.}
\end{center}

Il est également possible d'afficher les routes dans le shell avec la commande :
\begin{lstlisting}[language=bash] 
    $ ip route
\end{lstlisting} 

L'image nous dit que la route par défaut a empreunter si aucune des routes décrite ne convien est <IP>...

\subsection{Règles iptables pour laisser accès a internet a une machine}

L'architecture de notre réseau commence a prendre forme, mais il est maintenant temps de permettre au client de notre réseau privé d'avoir accès a internet. Car oui pour le moment seul le routeur est en possession d'une connexion internet car il est encore une fois connecté au réseau IEM. Pour réaliser cette manoeuvre appelé une translation d'adresse, nous allons utilisé les règles "iptables" :

\begin{lstlisting}[language=bash] 
    $ iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -o eno1 -j MASQUERADE
\end{lstlisting}

Cette commande permet au routeur de filtrer et donc de laisser passer les clients qui arrivent du sous réseau 10.1.2.0/24.

Afin de savoir si notre routeur était capable d'utiliser internet, nous avons installer "links2" et avec la commande : 
\begin{lstlisting}[language=bash] 
    $ links2 google.com
\end{lstlisting}

il nous étaient possible de surfer sur le web avec un affichage non graphique. 

\section{Service DHCP}
 Nous avons ensuite paramétré encore plus notre réseau avec la mise en place d'un service DHCP afin de définir les adresses à attribuer pour les machines (clients) se connectant sur notre réseau privé.
\subsection{Mise en place du DHCP}
\subsection{Fichier de log pour le DHCP}

\section{Sauvegarde automatique}
\subsection{Rsync}
\subsection{Cron}

\section{Manipulation paquets de Debian}
\subsection{Mise à jour du système}
\subsection{Les paquets}

Conclusion tp 1 

Introduction tp 1bis

\section{Interrogation d'un serveur DNS}
\subsection{Les commandes host, dig et nslookup}
\subsection{Fichier de renseignement du serveur DNS}
\subsection{Rôle du fichier /etc/hosts}

\section{Installation d'un DNS}

Pour la suite des explication il est important de préciser que nous avons choisie comme nom de domaine : agence.altantide.

\subsection{Mise en place du DNS}

Création des deux zones, (named.conf.local et named.conf.default-zone), copie du fichier "db.local" en "deb.agence.atlantide", copie de "db.127" en "db.agence.atlantide.inv" pour la zone de recherche inversé. Ajout des forwarders dans "named.conf.options". Redémarrage avec systemctl restart bind 9. Changement du dhcp pour prendre en compte le serveur DNS.

\subsection{Test réaliser afin de valider le DNS}
named-checkzone et named-checkconf pour vérifier la syntaxe
/var/log/syslog pour voir les erreurs si présente au démarrage
depuis le serveur : nslookup ip-client
depuis le serveur : nslookup nom-client
depuis un client connecté en filaire au routeur : nslookup ip-client
depuis un client connecté en filaire au routeur : nslookup nom-client
vers le serveur d'une autre agence : 
vers le client d'une autre agence :

Conclusion tp 1bis

Introduction tp 2

\section{Installation d'un serveur LAMP}
\subsection{Installation et mise en place d'Apache}

Test, localisation de la page web, création du compte utilisateur développeur, modification du serveur pour que www soit associé au dev web (crée dabs /srv), les bon droits, mise en place du virtuals hosts pointant sur /srv/www 

\subsection{Installation et mise en place de PostgreSQL}

Déroulement...

\subsection{Installation et mise en place de PHP}

Programme PHP qui se connecte a PostgreSQL et affichage infos pour la vérification.

\subsection{Installation et mise en place de MySQL}

Comme pour PostgreSQL et php

\subsection{Installation et mise en place d'un PDO}

\section{Script de routage et matrice de filtrage}
\subsection{Scripts de routage au démarrage}
\subsection{Règles iptables de la matrice de filtrage}


Conclusion tp 2

Introduction 3

\section{}
\subsection{}
\subsection{}

Conclusion tp 3

\end{document}
