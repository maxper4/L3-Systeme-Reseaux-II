\documentclass[a4paper,10pt]{article}
%\documentclass[a4paper,10pt]{scrartcl}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{hyperref}

\title{Rapport Systèmes et Réseaux II}
\author{Perion Maxence, Pinon Alexandre}
\date{}

\renewcommand*\contentsname{Sommaire}

\pdfinfo{%
  /Title    ()
  /Author   ()
  /Creator  ()
  /Producer ()
  /Subject  ()
  /Keywords ()
}

\begin{document}

\maketitle 
\tableofcontents

\newpage
\section{Introduction}
L'objectif de ces Travaux Pratiques a été de réaliser un serveur complet pour une agence fictive. Pour cela, nous étions en possession de deux machines: un serveur/routeur ainsi qu'un client, une machine simulant la connexion d'un appareil au réseau de l'agence. Nous sommes partis de zéro et dans un premier temps nous avons installé Debian sur notre serveur, une distribution GNU/Linux, sans interface graphique via le réseau IEM pour avoir un outil de travail. Premièrement, nous avons défini et paramétré notre adressage et routage, c'est à dire la façon d'attribuer les adresses IP et comment communiquer sur les différents réseaux. Afin de s'affranchir des adresses IP et pour s'approcher d'un cadre plus réaliste, nous avons deuxièmement mis en place sur le serveur un service de DNS, permettant d'utiliser des noms de domaines agissant comme des alias pour des adresses IP.  Troisièmement, nous avons mis en place ce qui pourrait servir pour héberger un site web pour notre agence grâce à une suite d'outils appelée un LAMP. Pour finir, nous avons mis en place un service d'authentification centralisé LDAP ainsi qu'un service de partage de fichiers Samba.

\section{Installation d'une distribution GNU/Linux sans interface graphique}

\subsection{Installation via le réseau}

La première étape pour commencer à travailler a tout simplement était d'installer une distribution Debian GNU/Linux sans interface graphique. En effet cette distribution est un système d'exploitation et va nous permettre pour la suite des manipulations d'avoir une base de travail. Afin d'installer cette distribution les administrateurs système et réseau nous on mit à disposition un boot via le réseau. En temps normal pour installer un système d'exploitation qu'elle qu'il soit, les utilisateurs lambda utilisent des clés USB ou disque dur qui permette de boot sur celle-ci. Le principe est le même sauf que cette installation se fait par le réseau IEM qui est le réseau de l'université de Bourgogne. Pour lancer l'installation nous devions brancher notre serveur sur le réseau et la démarrer depuis le bios en sélectionnant le bouton "PXE IEM". Une fois l'installation démarrée nous devions suivre les étapes d'installation, tel que le nom et mot de passe du root, la choix des partition du disque, le nom de domaine (sartre.iem)... 
Le disque est composé de 3 partitions, il est possible d'afficher les partitions et des détails supplémentaire avec la commande:

\begin{lstlisting}[language=bash]
  $ sudo fdisk -l
\end{lstlisting}

\begin{center}
 \includegraphics[width=22cm, height=6cm]{images/partitionDisque.PNG}
 % partitionDisque.PNG: 1115x234 px, 96dpi, 29.51x6.19 cm, bb=0 0 836 176
 \underline{Les 3 partitions d'un disque.}
\end{center}

Ici nous pouvons voir distinctement les différentes partition. Dont la partition général de 237.5 Go qui permet de stocker différentes chose tel que des paquets pour l'utilisation de Debian ou encore différents types de fichiers. De plus nous pouvons voir la partition qui permet l'échange entre Linux et Solaris, mais également un partition étendue qui est un conteneur de partition logiques.
Maintenant que Debian est installé sur notre routeur il est prêt à être configuré et utilisé pour différentes tâches. 

\section{Paramétrage du réseau}
Nous avons ensuite définis la répartition des adresses IP pour chaque groupe (chaque agence) et paramétré en conséquences les différentes interfaces réseaux sur le routeur puis le client.
Avant tout paramétrage il est important de préciser que nous avons branché le réseau IEM sur la carte réseau intégré à la carte mère sur routeur. La première carte réseau externe à était branchée au switch afin de permettre la communication avec les autres groupes. Dernièrement la deuxième carte réseau externe est branchée sur le client. Ici le but de la manipulation est de mettre en place un réseau d'entreprises et d'une infrastructure de services.

\subsection{Répartition des adresse IP (réseau Interconnexion et réseau privé)}
Chaque groupe de TP possède une IP et un masque de classe C pour le réseau d’interconnexion. Afin de mettre en place le réseau d’interconnexion nous avons pris une plage IP compris entre 192.168.1.1 et 192.168.1.5 avec ce masque 255.255.255.248, 248 car nous avions besoin de 3 bits pour définir l'ensemble des routeurs qui sont dans le sous-réseau. En effet nous voulions distribuer les IP pour 6 routeurs, 5 pour les groupes de TP et 1 pour le réseau d’interconnexion.
\begin{center}
 \includegraphics[width=16cm, height=6cm]{images/ReseauInterco&Prive.png}
 % ReseauInterco&Prive.png: 720x310 px, 96dpi, 19.05x8.20 cm, bb=0 0 540 232
 \underline{Tableau des adresses IP de chaque groupe.}
\end{center}

Ce petit tableau récapitule les adresses IP allouer pour chaque réseau et pour chaque groupe. Pour notre cas nous sommes dans le groupe 2 ce qui veut dire que notre adresse sur le réseau d’interconnexion est le "192.168.1.2" et notre adresse de réseau privé est le "10.1.2.0".

\subsection{Interfaces réseau du routeur}
Les adresses que nous venons de répartir entre chaque groupe doivent être utiliser par le routeur. C'est pour cela que nous allons maintenant expliquer comment nous avons paramétré les interfaces réseau sur le routeur. Pour cela il suffit simplement de se rendre dans le fichier /etc/network/interfaces et de modifier le fichier comme ceci: 
\begin{center}
 \includegraphics[width=16cm, height=6cm]{images/interfacesRouteur.png}
 % ReseauInterco&Prive.png: 720x310 px, 96dpi, 19.05x8.20 cm, bb=0 0 540 232
 \underline{Fichier de configuration des interfaces réseaux du routeur.}
\end{center}

Il est également possible d'afficher les interfaces réseaux dans le shell avec la commande:
\begin{lstlisting}[language=bash] 
    $ ip a 
\end{lstlisting} 
ce qui a pour intérêt de connaître rapidement les macs adresse et/ou IP de chacun, mais permet également de savoir si une interface est en route "UP" ou pas "DOWN". En effet durant les phases de test il était important de savoir qu'elle interfaces était allumée ou éteinte, il nous est arrivé de relancer une interface à la main via la commande 

\begin{lstlisting}[language=bash] 
    $ ip link set enp3s0 up
\end{lstlisting}

Pour le fichier de configuration ci-dessus nous pouvons voire les 3 interfaces donc les 3 port Ethernet que possède notre routeur, ainsi que l'interface "lo" qui représente le loopback. Pour chacune d'entre elle leurs adresses (address), leurs masques (netmask) et leurs réseaux (network) sont indiqué. Pour l'interface "eno1" qui est relié au réseau IEM, nous avons plusieurs information supplémentaire ; l'adresse de broadcast ainsi que la passerelle (gateway). De plus nous pouvons maintenant différencier clairement qu'elle interface fait référence a qu'elle utilisation. En effet l'interface "eno1" est relier au réseau IEM car pour le réseau nous avons indiqué l'adresse "172.31.20.1" qui est l'adresse du routeur du réseau IEM fournie par les intervenants de travaux pratiques. Le raisonnement est le même pour les interfaces "enp3s0" et "enp1s0", pour lesquels nous avons indiquer respectivement pour le réseau "10.1.2.0" et "192.158.1.0". Et qui sont donc les réseaux d'interconnexion et privé. Les informations "dns-nameservers" et "pre-up" seront expliqué ultérieurement. Le fichier de configuration des interfaces réseaux est actuellement écrit et prêt a l'emploie, mais ce n'est pas pour autant que les interfaces vont changer. En effet pour que les modifications soit prise en compte il faut redémarrer le service associer en tant que root ou alors avec sudo:

\begin{lstlisting}[language=bash] 
    $ service networking restart
    ou
    $ /etc/init.d/networking restart
    ou
    $ systemctl restart networking
\end{lstlisting}
Ces 3 commandes permette de redémarrer le service qui s'occupe des interfaces réseaux. 

\subsection{Interfaces réseau du client}

Nous allons maintenant expliquer comment nous avons paramétré les interfaces réseau sur le client. Comme pour le routeur le fichier de configuration se trouve dans /etc/network/interfaces.
Par conséquent la forme du fichier est similaire a celui du routeur. Voici les informations que nous retrouvons sur le fichier et qui renseigne l'adresse, le masque et le réseau de l'interface réseau de notre client. 

\begin{lstlisting}[language=bash]
    auto enp11s0
    iface enp11s0 inet static
                address 10.1.2.2
                netmask 255.255.255.0
                network 10.1.2.0
                gateway 10.1.2.1
\end{lstlisting}
On voit ici que l'IP renseigné pour le réseau donc le network pour l'interface "enp11s0" est "10.1.2.1", qui est l'adresse du de notre sous réseau. On connais désormais l'IP de notre client qui est "10.1.2.2".
Comme pour le routeur afin d'appliquer les changements il faut redémarrer le service avec l'une des trois commande donnée pour le routeur. Par la suite toutes ces configuration vont permettre aux client et routeur de communiquer avec le reste des groupes. 

\subsection{Communication sans table de routage}

Nous allons maintenant aborder la communication entre différente machine, car en effet nous avons pour but de simuler un réseau en entreprise, et par conséquent il faut que nos machines puisse communiquer, et que le routeur sois en capacité de rediriger correctement les machines ou elle souhaite aller. Par défaut le client et le routeur peuvent communiquer car il sont branché physiquement entre eux. Il en est de même pour tous les routeurs qui sont brancher sur le réseau IEM car ils sont tous sur le même réseau. Afin de tester les communication entre différentes machines, que se soit routeurs ou clients, il nous suffit simplement de ping la machine avec sont IP et avec cette commande: 
\begin{lstlisting}[language=bash]
  $ ping ip_machine
\end{lstlisting}

Par exemple avec notre routeur nous allons ping le routeur d'un groupe d'amis via le réseau IEM:
\begin{center}
 \includegraphics[width=16cm, height=6cm]{images/routeurPingRouteur.png}
 % ReseauInterco&Prive.png: 720x310 px, 96dpi, 19.05x8.20 cm, bb=0 0 540 232
 \underline{Ping de notre routeur à un autre.}
\end{center}

Nous pouvons voir ici que les paquets sont bien envoyé et reçu par notre correspondant. Donc pas de soucis pour ping un autre routeur. Mais si notre routeur ou notre client veut ping ou plus couramment communiquer avec un client d'un autre groupe qui est donc sur un réseau privé, on va devoir lui indiquer le chemin pour aller jusqu'à celui-ci.

\subsection{Mise en place de la table de routage}

L'étape suivante est la création de routes afin de faire communiquer les différentes machines de la simulation: le client et le routeur, mais également entre chaque routeurs (les autres agences) et entre différents clients de différentes agences.
Dans la configuration actuelle il nous est impossible de ping le client qui passe par un autre routeur que le notre, en effet pour arriver a faire ceci il nous faut mettre en place une table de routage.
La table de routage permet d'indiquer les routes a prendre par tel ou tel machines. 

Il est possible d'afficher les routes dans le shell avec la commande:
\begin{lstlisting}[language=bash] 
    $ ip route
\end{lstlisting} 

\begin{center}
 \includegraphics[width=16cm, height=6cm]{images/routeRouteur.png}
 % ReseauInterco&Prive.png: 720x310 px, 96dpi, 19.05x8.20 cm, bb=0 0 540 232
 \underline{Route de notre routeur.}
\end{center}

L'image nous dit que la route par défaut à emprunter pour toutes les machines qui arrive, si aucune des routes décrite ne conviens est la route par l'adresse "172.31.20.1". Ce qui redirige les machines au routeur du réseau IEM. Elle permet également de savoir que la machine avec l'IP "10.1.2.1" est redirigé sur le sous réseau "10.1.2.0/24", de même pour l'adresse "172.31.20.112" qui est redirigé sur le sous réseau "172.31.20.0/24", et "192.168.1.2" redirigé sur "192.168.1.0/29" qui est donc le réseau d'interconnexion.

Les routes statiques sont ajoutés via la commande en tant que root ou utiliser sudo dans le cas contraire: 
\begin{lstlisting}[language=bash] 
    $ ip route add {network} via {IP}
\end{lstlisting}

Maintenant nous cherchons le moyen de permettre la communication entre notre routeur et le client d'un autre groupe d'amis. Et dans un second temps permettre la communication entre notre client et le client de l'autre groupe. Le groupe avec qui nous effectuons les tests, on pour réseau d'interconnexion l'IP "192.168.1.1", pour réseau privé "10.1.1.0" et l'IP de leur client et la suivante "10.1.1.1".

Donc sur notre routeur il faut appliquer la commande: 
\begin{lstlisting}[language=bash] 
    $ ip route add 10.1.1.0/24 via 192.168.1.1
\end{lstlisting}
Cette commande permet de dire que tous ce qui arrive sur le routeur "192.168.1.1" donc le routeur de notre groupe de test, est redirigé sur le réseau privé "10.1.1.0". Donc si avec notre routeur nous tapons la commande qui permet de ping leur client:
\begin{lstlisting}[language=bash] 
    $ ping 10.1.1.1
\end{lstlisting}
est bien ceci fonctionne, en effet nos paquets sont belle est bien envoyé et réceptionné. 

Et dans un second temps sur notre client appliquer la commande: 
\begin{lstlisting}[language=bash] 
    $ ip route add 10.1.1.0/24 via 10.1.2.1
\end{lstlisting}
Cette commande permet de dire que tous ce qui part de notre client "10.1.2.1", est redirigé sur le réseau privé "10.1.1.0" de notre groupe d'amis. Donc si avec notre client nous tapons la commande qui permet de ping leur client:
\begin{lstlisting}[language=bash] 
    $ ping 10.1.1.1
\end{lstlisting}
est bien ceci fonctionne. Tous comme notre routeur nos paquets sont belle est bien envoyé et réceptionné. 

\subsection{Règles iptables pour laisser l'accès a internet a une machine}

L'architecture de notre réseau commence a prendre forme, mais il est maintenant temps de permettre au client de notre réseau privé d'avoir accès a internet. Car oui pour le moment seul le routeur est en possession d'une connexion internet car il est encore une fois connecté au réseau IEM. Pour réaliser cette manoeuvre appelé une translation d'adresse, nous allons utilisé les règles "iptables":

\begin{lstlisting}[language=bash] 
    $ iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -o eno1 -j MASQUERADE
\end{lstlisting}

Cette commande permet au routeur d'accepter les paquets retransmis via le périphérique d'IP interne du pare-feu par l'interface "eno1", et donc de laisser passer les données qui sont destinée au clients qui sont dans le sous réseau "10.1.2.0/24".

Afin de vérifier si notre routeur était capable d'utiliser internet, nous avons installer "links2" qui a était auparavant installé via le gestionnaire de paquet "apt" et avec la commande: 
\begin{lstlisting}[language=bash] 
    $ links2 google.com
\end{lstlisting}
Et en effet notre routeur était capable de surfer sur le web avec un affichage non graphique. Dans ce cas nous avons appliquer la même procedure pour notre client afin de vérifier si il possédais une connexion internet.

\section{Service DHCP}
Maintenant partons du principe que nous souhaitons posséder plusieurs clients sur notre réseau privé, il est alors important d'approfondir le paramétrage de notre réseau avec la mise en place d'un service DHCP afin de définir les adresses IP à attribuer pour les machines (clients) se connectant sur notre réseau privé.
\subsection{Mise en place du DHCP}

Avant toute chose, nous avons cherché et installé le bon paquet pour l'utilisation du DHCP:
\begin{lstlisting}[language=bash] 
    $ apt-get install isc-dhcp-server
\end{lstlisting}
Une fois l'installation effectué nous nous somme rendu dans le fichier "/etc/default/isc-dhcp-server" qui à était installé grâce a la commande donné précédemment. Dans ce fichier il faut renseigner sur qu'elle interface réseau nous voulons travailler pour la suite de la mise du DHCP.

\begin{center}
 \includegraphics[width=16cm, height=6cm]{images/dhcpServeur.png}
 % ReseauInterco&Prive.png: 720x310 px, 96dpi, 19.05x8.20 cm, bb=0 0 540 232
 \underline{Interface du DHCP.}
\end{center}

Comme nous voulons allouer automatiquement les adresses IP de chaques clients connecté a notre réseau privé nous avons utilisé l'interface "enp3s0".
Ceci étant fait nous voulons paramétré en détails le serveur DHCP, comme par example la plage d'adresse IP qui va être subneter, ou encore des adresses fixe pour des postes en particulier. La configuration du serveur DHCP se fait sur le fichier "/etc/dhcp/dhcpd.conf".

\begin{center}
 \includegraphics[width=16cm, height=6cm]{images/dhcpdConfServeur.png}
 % ReseauInterco&Prive.png: 720x310 px, 96dpi, 19.05x8.20 cm, bb=0 0 540 232
 \underline{Configuration du serveur DHCP.}
\end{center}
Sur cette capture d'écran nous pouvons voir que le réseau subneter est tout naturellement notre réseau privé avec l'adresse "10.1.2.0" et le masque "255.255.255.0". Nous attribuons une adresse fixe a plusieurs clients car durant nos test il est arrivé que nous ayons des clients différents. Afin d'attribuer une adresse fixe il suffit d'indiquer l'adresse qu'il va récupérer "fixed-address" ainsi que sa mac adresse "hardware ethernet".
Nous avons également renseigné différente informations concernant le DNS mais nous aborderons le sujet plus tard.

Tous comme les interfaces réseau quand une modification est apporté il faut redémarrer le service associer afin de prendre en compte les changement effectué, avec la commande:

\begin{lstlisting}[language=bash] 
    $ service isc-dhcp-server restart
\end{lstlisting}

Il est également possible de démarrer le service si il est arrêter avec:
\begin{lstlisting}[language=bash] 
    $ service isc-dhcp-server start
\end{lstlisting}
Ou a contrario le stopper si besoin avec:
\begin{lstlisting}[language=bash] 
    $ service isc-dhcp-server stop
\end{lstlisting}
Il est également possible d'afficher les erreurs en cas de soucis avec:
\begin{lstlisting}[language=bash] 
    $ cat /var/log/syslog
\end{lstlisting}
Et finalement on peut afficher l'interface d'écoute du démon avec:
\begin{lstlisting}[language=bash] 
    $ ps ax | grep dhcpd
\end{lstlisting}
Une fois que tout est mis en place et que tout est opérationnel, il nous faut une trace de ce qu'il va se passer. C'est pour cela que nous avons besoin de mettre un place un système de log pour serveur DHCP.

\subsection{Système de log pour le DHCP}

\section{Sauvegarde automatique}
\subsection{Rsync}
\subsection{Cron}

\section{Manipulation paquets de Debian}
Sous Debian il existe de multiple gestionnaire de paquets, mais le plus couramment utilisé est le gestionnaire "apt".
\subsection{Mise à jour du système}
\subsection{Les paquets}

Conclusion tp 1 

Introduction tp 1bis

\section{Interrogation d'un serveur DNS}
\subsection{Les commandes host, dig et nslookup}
\subsection{Fichier de renseignement du serveur DNS}
\subsection{Rôle du fichier /etc/hosts}

\section{Installation d'un DNS}

Pour la suite des explication il est important de préciser que nous avons choisie comme nom de domaine: agence.altantide.

\subsection{Mise en place du DNS}

Création des deux zones, (named.conf.local et named.conf.default-zone), copie du fichier "db.local" en "deb.agence.atlantide", copie de "db.127" en "db.agence.atlantide.inv" pour la zone de recherche inversé. Ajout des forwarders dans "named.conf.options". Redémarrage avec systemctl restart bind 9. Changement du dhcp pour prendre en compte le serveur DNS.
"option domain-name "agence.atlantide" fournit le nom de domaine, dans ce cas il sert a faire référence aux ordinateurs du réseau par leurs nom sans ajouter le nom de domaine.

\subsection{Test réaliser afin de valider le DNS}
named-checkzone et named-checkconf pour vérifier la syntaxe
/var/log/syslog pour voir les erreurs si présente au démarrage
depuis le serveur : nslookup ip-client
depuis le serveur : nslookup nom-client
depuis un client connecté en filaire au routeur : nslookup ip-client
depuis un client connecté en filaire au routeur : nslookup nom-client
vers le serveur d'une autre agence : 
vers le client d'une autre agence :

Conclusion tp 1bis

Introduction tp 2

\section{Installation d'un serveur LAMP}
\subsection{Installation et mise en place d'Apache}

Test, localisation de la page web, création du compte utilisateur développeur, modification du serveur pour que www soit associé au dev web (crée dabs /srv), les bon droits, mise en place du virtuals hosts pointant sur /srv/www 

\subsection{Installation et mise en place de PostgreSQL}

Déroulement...

\subsection{Installation et mise en place de PHP}

Programme PHP qui se connecte a PostgreSQL et affichage infos pour la vérification.

\subsection{Installation et mise en place de MySQL}

Comme pour PostgreSQL et php

\subsection{Installation et mise en place d'un PDO}

\section{Script de routage et matrice de filtrage}
\subsection{Scripts de routage au démarrage}
\subsection{Règles iptables de la matrice de filtrage}


Conclusion tp 2

Introduction 3

\section{}
\subsection{}
\subsection{}

Conclusion tp 3

\end{document}
